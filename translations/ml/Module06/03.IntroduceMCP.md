# Section 03 - മോഡൽ കോൺടെക്സ്റ്റ് പ്രോട്ടോക്കോൾ (MCP) ഇന്റഗ്രേഷൻ

## MCP (Model Context Protocol) പരിചയം

Model Context Protocol (MCP) ഒരു ഓപ്പൺ-സോഴ്‌സ് സ്റ്റാൻഡേർഡാണ്, AI ആപ്ലിക്കേഷനുകൾക്ക് ബാഹ്യ സിസ്റ്റങ്ങളുമായി ബന്ധിപ്പിക്കാൻ. MCP ഉപയോഗിച്ച്, Claude അല്ലെങ്കിൽ ChatGPT പോലുള്ള AI ആപ്ലിക്കേഷനുകൾ ഡാറ്റാ സ്രോതസ്സുകൾ (ഉദാ: ലോക്കൽ ഫയലുകൾ, ഡാറ്റാബേസുകൾ), ടൂളുകൾ (ഉദാ: സെർച്ച് എഞ്ചിനുകൾ, കാൽക്കുലേറ്ററുകൾ), വർക്ക്‌ഫ്ലോകൾ (ഉദാ: പ്രത്യേക പ്രോംപ്റ്റുകൾ) എന്നിവയുമായി ബന്ധിപ്പിച്ച് പ്രധാന വിവരങ്ങൾ ആക്‌സസ് ചെയ്ത് പ്രവർത്തനങ്ങൾ നടത്താൻ കഴിയും.

MCP-നെ AI ആപ്ലിക്കേഷനുകൾക്കുള്ള **USB-C പോർട്ട്** എന്നിങ്ങനെ ചിന്തിക്കാം. USB-C ഇലക്ട്രോണിക് ഉപകരണങ്ങൾ ബന്ധിപ്പിക്കാൻ ഒരു സ്റ്റാൻഡേർഡ് മാർഗം നൽകുന്നതുപോലെ, MCP AI ആപ്ലിക്കേഷനുകൾ ബാഹ്യ സിസ്റ്റങ്ങളുമായി ബന്ധിപ്പിക്കാൻ ഒരു സ്റ്റാൻഡേർഡ് മാർഗം നൽകുന്നു.

### MCP എന്തെന്ത് സാധ്യമാക്കുന്നു?

MCP AI ആപ്ലിക്കേഷനുകൾക്ക് ശക്തമായ കഴിവുകൾ തുറക്കുന്നു:

- **വ്യക്തിഗത AI അസിസ്റ്റന്റുകൾ**: ഏജന്റുകൾ നിങ്ങളുടെ Google Calendar, Notion എന്നിവ ആക്‌സസ് ചെയ്ത് കൂടുതൽ വ്യക്തിഗതമായ AI അസിസ്റ്റന്റായി പ്രവർത്തിക്കും
- **അഡ്വാൻസ്ഡ് കോഡ് ജനറേഷൻ**: Claude Code ഒരു Figma ഡിസൈൻ ഉപയോഗിച്ച് മുഴുവൻ വെബ് ആപ്പ് സൃഷ്ടിക്കാം
- **എന്റർപ്രൈസ് ഡാറ്റ ഇന്റഗ്രേഷൻ**: എന്റർപ്രൈസ് ചാറ്റ്ബോട്ടുകൾ ഒരു സംഘടനയിലെ പല ഡാറ്റാബേസുകളുമായി ബന്ധിപ്പിച്ച് ഉപയോക്താക്കൾക്ക് ചാറ്റ് വഴി ഡാറ്റ വിശകലനം ചെയ്യാൻ സഹായിക്കും
- **സൃഷ്ടിപരമായ വർക്ക്‌ഫ്ലോകൾ**: AI മോഡലുകൾ Blender-ൽ 3D ഡിസൈനുകൾ സൃഷ്ടിച്ച് 3D പ്രിന്റർ ഉപയോഗിച്ച് പ്രിന്റ് ചെയ്യാം
- **റിയൽ-ടൈം വിവര ആക്‌സസ്**: അപ്‌ഡേറ്റായ വിവരങ്ങൾക്ക് ബാഹ്യ ഡാറ്റാ സ്രോതസ്സുകളുമായി ബന്ധിപ്പിക്കുക
- **സങ്കീർണ്ണമായ മൾട്ടി-സ്റ്റെപ്പ് പ്രവർത്തനങ്ങൾ**: പല ടൂളുകളും സിസ്റ്റങ്ങളും സംയോജിപ്പിച്ച് സങ്കീർണ്ണ വർക്ക്‌ഫ്ലോകൾ നടത്തുക

### MCP എന്തുകൊണ്ട് പ്രധാനമാണ്?

MCP ഇക്കോസിസ്റ്റത്തിൽ വിവിധ ഗുണങ്ങൾ നൽകുന്നു:

**ഡെവലപ്പർമാർക്ക്**: MCP AI ആപ്ലിക്കേഷൻ അല്ലെങ്കിൽ ഏജന്റ് നിർമ്മിക്കുമ്പോൾ വികസന സമയം കുറയ്ക്കുകയും സങ്കീർണ്ണത കുറയ്ക്കുകയും ചെയ്യുന്നു.

**AI ആപ്ലിക്കേഷനുകൾക്ക്**: MCP ഡാറ്റാ സ്രോതസ്സുകൾ, ടൂളുകൾ, ആപ്ലിക്കേഷനുകളുടെ ഇക്കോസിസ്റ്റത്തിലേക്ക് ആക്‌സസ് നൽകുന്നു, കഴിവുകൾ വർദ്ധിപ്പിക്കുകയും ഉപയോക്തൃ അനുഭവം മെച്ചപ്പെടുത്തുകയും ചെയ്യുന്നു.

**അവസാന ഉപയോക്താക്കൾക്ക്**: MCP നിങ്ങളുടെ ഡാറ്റ ആക്‌സസ് ചെയ്ത് ആവശ്യമായപ്പോൾ നിങ്ങളുടെ പകരം പ്രവർത്തനങ്ങൾ നടത്താൻ കഴിയുന്ന കൂടുതൽ കഴിവുള്ള AI ആപ്ലിക്കേഷനുകൾ അല്ലെങ്കിൽ ഏജന്റുകൾ നൽകുന്നു.

## MCP-യിൽ ചെറിയ ഭാഷാ മോഡലുകൾ (SLMs)

ചെറിയ ഭാഷാ മോഡലുകൾ AI വിനിയോഗത്തിന് കാര്യക്ഷമമായ സമീപനമാണ്, പല ഗുണങ്ങളും നൽകുന്നു:

### SLM-കളുടെ ഗുണങ്ങൾ
- **സ്രോതസ്സ് കാര്യക്ഷമത**: കുറഞ്ഞ കംപ്യൂട്ടേഷൻ ആവശ്യകതകൾ
- **വേഗത്തിലുള്ള പ്രതികരണ സമയം**: റിയൽ-ടൈം ആപ്ലിക്കേഷനുകൾക്ക് കുറഞ്ഞ ലാറ്റൻസി  
- **ചെലവ് കുറഞ്ഞത്**: കുറഞ്ഞ ഇൻഫ്രാസ്ട്രക്ചർ ആവശ്യകതകൾ
- **സ്വകാര്യത**: ഡാറ്റ ട്രാൻസ്മിഷൻ ഇല്ലാതെ ലോക്കലായി പ്രവർത്തിക്കാം
- **കസ്റ്റമൈസേഷൻ**: പ്രത്യേക ഡൊമെയ്‌നുകൾക്കായി എളുപ്പത്തിൽ ഫൈൻ-ട്യൂൺ ചെയ്യാം

### MCP-യുമായി SLM-കൾ എങ്ങനെ നല്ലത്?

SLM-കൾ MCP-യുമായി ചേർന്ന് മോഡലിന്റെ റീസണിംഗ് കഴിവുകൾ ബാഹ്യ ടൂളുകൾ ഉപയോഗിച്ച് വർദ്ധിപ്പിക്കുന്നു, ചെറിയ പാരാമീറ്റർ എണ്ണം ഫംഗ്ഷണാലിറ്റി വർദ്ധിപ്പിച്ച് പൂരിപ്പിക്കുന്നു.

## Python MCP SDK അവലോകനം

Python MCP SDK MCP-സജ്ജമായ ആപ്ലിക്കേഷനുകൾ നിർമ്മിക്കാൻ അടിസ്ഥാനമാകുന്നു. SDK ഉൾപ്പെടുന്നു:

- **ക്ലയന്റ് ലൈബ്രറികൾ**: MCP സെർവറുകളുമായി ബന്ധിപ്പിക്കാൻ
- **സെർവർ ഫ്രെയിംവർക്ക്**: കസ്റ്റം MCP സെർവർ നിർമ്മിക്കാൻ
- **പ്രോട്ടോക്കോൾ ഹാൻഡ്ലറുകൾ**: കമ്മ്യൂണിക്കേഷൻ മാനേജുചെയ്യാൻ
- **ടൂൾ ഇന്റഗ്രേഷൻ**: ബാഹ്യ ഫംഗ്ഷനുകൾ പ്രവർത്തിപ്പിക്കാൻ

## പ്രായോഗിക നടപ്പാക്കൽ: Phi-4 MCP ക്ലയന്റ്

Microsoft-ന്റെ Phi-4 മിനി മോഡൽ MCP കഴിവുകളുമായി സംയോജിപ്പിച്ചുള്ള യഥാർത്ഥ നടപ്പാക്കൽ പരിശോധിക്കാം.

### MCP ആർക്കിടെക്ചർ അവലോകനം

MCP ഒരു **ക്ലയന്റ്-സെർവർ ആർക്കിടെക്ചർ** പിന്തുടരുന്നു, MCP ഹോസ്റ്റ് (Claude Code അല്ലെങ്കിൽ Claude Desktop പോലുള്ള AI ആപ്ലിക്കേഷൻ) ഒരു അല്ലെങ്കിൽ കൂടുതൽ MCP സെർവറുകളുമായി ബന്ധം സ്ഥാപിക്കുന്നു. MCP ഹോസ്റ്റ് ഓരോ MCP സെർവറിനും ഒരു MCP ക്ലയന്റ് സൃഷ്ടിച്ച് ഇത് സാധ്യമാക്കുന്നു.

#### പ്രധാന പങ്കാളികൾ

- **MCP ഹോസ്റ്റ്**: ഒറ്റയോ ഒന്നിലധികമോ MCP ക്ലയന്റുകളെ ഏകോപിപ്പിക്കുകയും നിയന്ത്രിക്കുകയും ചെയ്യുന്ന AI ആപ്ലിക്കേഷൻ
- **MCP ക്ലയന്റ്**: MCP സെർവറുമായി ബന്ധം നിലനിർത്തുകയും MCP ഹോസ്റ്റ് ഉപയോഗിക്കാൻ MCP സെർവറിൽ നിന്നുള്ള കോൺടെക്സ്റ്റ് നേടുകയും ചെയ്യുന്ന ഘടകം
- **MCP സെർവർ**: MCP ക്ലയന്റുകൾക്ക് കോൺടെക്സ്റ്റ് നൽകുന്ന പ്രോഗ്രാം

#### രണ്ട് ലെയർ ആർക്കിടെക്ചർ

MCP രണ്ട് വ്യത്യസ്ത ലെയറുകൾ ഉൾക്കൊള്ളുന്നു:

**ഡാറ്റ ലെയർ**: ക്ലയന്റ്-സെർവർ കമ്മ്യൂണിക്കേഷനിനുള്ള JSON-RPC അടിസ്ഥാനമാക്കിയ പ്രോട്ടോക്കോൾ നിർവചിക്കുന്നു, ഇതിൽ ഉൾപ്പെടുന്നു:
- ലൈഫ്‌സൈക്കിൾ മാനേജ്മെന്റ് (ബന്ധം ആരംഭിക്കൽ, കഴിവ് ചർച്ച)
- കോർ പ്രിമിറ്റീവുകൾ (ടൂളുകൾ, റിസോഴ്‌സുകൾ, പ്രോംപ്റ്റുകൾ)
- ക്ലയന്റ് ഫീച്ചറുകൾ (സാമ്പ്ലിംഗ്, എലിസിറ്റേഷൻ, ലോഗിംഗ്)
- ഉപകാര ഫീച്ചറുകൾ (നോട്ടിഫിക്കേഷനുകൾ, പുരോഗതി ട്രാക്കിംഗ്)

**ട്രാൻസ്പോർട്ട് ലെയർ**: കമ്മ്യൂണിക്കേഷൻ മെക്കാനിസങ്ങളും ചാനലുകളും നിർവചിക്കുന്നു:
- **STDIO ട്രാൻസ്പോർട്ട്**: ലോക്കൽ പ്രോസസ്സുകൾക്കായി സ്റ്റാൻഡേർഡ് ഇൻപുട്ട്/ഔട്ട്പുട്ട് സ്ട്രീമുകൾ ഉപയോഗിക്കുന്നു (മികച്ച പ്രകടനം, നെറ്റ്‌വർക്ക് ഓവർഹെഡ് ഇല്ല)
- **Streamable HTTP ട്രാൻസ്പോർട്ട്**: HTTP POST ഉപയോഗിച്ച് ഓപ്ഷണൽ Server-Sent Events ഉപയോഗിച്ച് റിമോട്ട് സെർവറുകൾക്കായി (സ്റ്റാൻഡേർഡ് HTTP ഓതന്റിക്കേഷൻ പിന്തുണ)

```
┌─────────────────────────────────────┐
│           MCP Host                  │
│     (AI Application)                │
└─────────────────┬───────────────────┘
                  │
┌─────────────────┴───────────────────┐
│         MCP Client 1                │
│  ┌─────────────────────────────────┐ │
│  │        Data Layer               │ │
│  │  ├── Lifecycle Management       │ │
│  │  ├── Primitives (Tools/Resources)│ │
│  │  └── Notifications              │ │
│  └─────────────────────────────────┘ │
│  ┌─────────────────────────────────┐ │
│  │      Transport Layer           │ │
│  │  ├── STDIO Transport           │ │
│  │  └── HTTP Transport            │ │
│  └─────────────────────────────────┘ │
└─────────────────┬───────────────────┘
                  │
┌─────────────────┴───────────────────┐
│         MCP Server 1                │
│    (Local/Remote Context Provider)  │
└─────────────────────────────────────┘
```

### MCP കോർ പ്രിമിറ്റീവുകൾ

MCP AI ആപ്ലിക്കേഷനുകളുമായി പങ്കുവെക്കാവുന്ന കോൺടെക്സ്റ്റ് വിവരങ്ങളുടെ തരം നിർവചിക്കുന്ന പ്രിമിറ്റീവുകളും നിർവഹിക്കാവുന്ന പ്രവർത്തനങ്ങളുടെ പരിധിയും നിർവചിക്കുന്നു.

#### സെർവർ പ്രിമിറ്റീവുകൾ

MCP സെർവർകൾക്ക് തുറക്കാവുന്ന മൂന്ന് കോർ പ്രിമിറ്റീവുകൾ നിർവചിക്കുന്നു:

**ടൂളുകൾ**: AI ആപ്ലിക്കേഷനുകൾ പ്രവർത്തനങ്ങൾ നടത്താൻ വിളിക്കാവുന്ന എക്സിക്യൂട്ടബിൾ ഫംഗ്ഷനുകൾ  
- ഉദാഹരണങ്ങൾ: ഫയൽ ഓപ്പറേഷനുകൾ, API കോൾസ്, ഡാറ്റാബേസ് ക്വെറികൾ  
- മെത്തഡുകൾ: `tools/list`, `tools/call`  
- ഡൈനാമിക് കണ്ടെത്തലും എക്സിക്യൂഷനും പിന്തുണയ്ക്കുന്നു

**റിസോഴ്‌സുകൾ**: AI ആപ്ലിക്കേഷനുകൾക്ക് കോൺടെക്സ്റ്റ് വിവരങ്ങൾ നൽകുന്ന ഡാറ്റാ സ്രോതസ്സുകൾ  
- ഉദാഹരണങ്ങൾ: ഫയൽ ഉള്ളടക്കം, ഡാറ്റാബേസ് റെക്കോർഡുകൾ, API പ്രതികരണങ്ങൾ  
- മെത്തഡുകൾ: `resources/list`, `resources/read`  
- ഘടനയുള്ള ഡാറ്റ ആക്‌സസ് ചെയ്യാൻ സഹായിക്കുന്നു

**പ്രോംപ്റ്റുകൾ**: ഭാഷാ മോഡലുകളുമായി ഇടപെടലുകൾ ഘടിപ്പിക്കാൻ സഹായിക്കുന്ന പുനരുപയോഗയോഗ്യമായ ടെംപ്ലേറ്റുകൾ  
- ഉദാഹരണങ്ങൾ: സിസ്റ്റം പ്രോംപ്റ്റുകൾ, ഫ്യൂ-ഷോട്ട് ഉദാഹരണങ്ങൾ  
- മെത്തഡുകൾ: `prompts/list`, `prompts/get`  
- AI ഇടപെടൽ മാതൃകകൾ സ്റ്റാൻഡർഡൈസ് ചെയ്യുന്നു

#### ക്ലയന്റ് പ്രിമിറ്റീവുകൾ

MCP ക്ലയന്റുകൾക്ക് സമ്പന്നമായ ഇടപെടലുകൾ അനുവദിക്കാൻ പ്രിമിറ്റീവുകളും നിർവചിക്കുന്നു:

**സാമ്പ്ലിംഗ്**: സെർവർകൾക്ക് ക്ലയന്റിന്റെ AI ആപ്ലിക്കേഷനിൽ നിന്നുള്ള ഭാഷാ മോഡൽ പൂർത്തീകരണങ്ങൾ അഭ്യർത്ഥിക്കാൻ അനുവദിക്കുന്നു  
- മെത്തഡ്: `sampling/complete`  
- മോഡൽ-സ്വതന്ത്ര സെർവർ വികസനം സാധ്യമാക്കുന്നു  
- ഹോസ്റ്റിന്റെ ഭാഷാ മോഡലിലേക്ക് ആക്‌സസ് നൽകുന്നു

**എലിസിറ്റേഷൻ**: സെർവർകൾക്ക് ഉപയോക്താക്കളിൽ നിന്ന് അധിക വിവരങ്ങൾ അഭ്യർത്ഥിക്കാൻ അനുവദിക്കുന്നു  
- മെത്തഡ്: `elicitation/request`  
- ഉപയോക്തൃ ഇടപെടലും സ്ഥിരീകരണവും സാധ്യമാക്കുന്നു  
- ഡൈനാമിക് വിവര ശേഖരണം പിന്തുണയ്ക്കുന്നു

**ലോഗിംഗ്**: സെർവർകൾക്ക് ക്ലയന്റുകൾക്ക് ലോഗ് സന്ദേശങ്ങൾ അയയ്ക്കാൻ അനുവദിക്കുന്നു  
- ഡീബഗ്ഗിംഗിനും നിരീക്ഷണത്തിനും ഉപയോഗിക്കുന്നു  
- സെർവർ പ്രവർത്തനങ്ങളിൽ ദൃശ്യത നൽകുന്നു

### MCP പ്രോട്ടോക്കോൾ ലൈഫ്‌സൈക്കിൾ

#### ആരംഭവും കഴിവ് ചർച്ചയും

MCP ഒരു സ്റ്റേറ്റ്‌ഫുൾ പ്രോട്ടോക്കോൾ ആണ്, ലൈഫ്‌സൈക്കിൾ മാനേജ്മെന്റ് ആവശ്യമാണ്. ആരംഭ പ്രക്രിയ പല പ്രധാന ലക്ഷ്യങ്ങൾ നിറവേറ്റുന്നു:

1. **പ്രോട്ടോക്കോൾ വേർഷൻ ചർച്ച**: ക്ലയന്റും സെർവറും അനുയോജ്യമായ പ്രോട്ടോക്കോൾ വേർഷനുകൾ ഉപയോഗിക്കുന്നുണ്ടെന്ന് ഉറപ്പാക്കുന്നു (ഉദാ: "2025-06-18")  
2. **കഴിവ് കണ്ടെത്തൽ**: ഓരോ പാർട്ടിയും പിന്തുണയുള്ള ഫീച്ചറുകളും പ്രിമിറ്റീവുകളും പ്രഖ്യാപിക്കുന്നു  
3. **ഐഡന്റിറ്റി എക്സ്ചേഞ്ച്**: തിരിച്ചറിയലും വേർഷനിംഗ് വിവരങ്ങളും നൽകുന്നു

```python
# ഉദാഹരണ ഇൻഷിയലൈസേഷൻ അഭ്യർത്ഥന
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "initialize",
  "params": {
    "protocolVersion": "2025-06-18",
    "capabilities": {
      "elicitation": {},  # ക്ലയന്റ് ഉപയോക്തൃ ഇടപെടൽ പിന്തുണയ്ക്കുന്നു
      "sampling": {}      # ക്ലയന്റ് LLM പൂർത്തീകരണങ്ങൾ നൽകാൻ കഴിയും
    },
    "clientInfo": {
      "name": "edge-ai-client",
      "version": "1.0.0"
    }
  }
}
```

#### ടൂൾ കണ്ടെത്തലും എക്സിക്യൂഷനും

ആരംഭശേഷം, ക്ലയന്റുകൾ ടൂളുകൾ കണ്ടെത്തുകയും പ്രവർത്തിപ്പിക്കുകയും ചെയ്യാം:

```python
# ലഭ്യമായ ഉപകരണങ്ങൾ കണ്ടെത്തുക
tools_response = await session.list_tools()

# ഒരു ഉപകരണം പ്രവർത്തിപ്പിക്കുക
result = await session.call_tool(
    "weather_current",
    {
        "location": "San Francisco",
        "units": "imperial"
    }
)
```

#### റിയൽ-ടൈം നോട്ടിഫിക്കേഷനുകൾ

MCP ഡൈനാമിക് അപ്‌ഡേറ്റുകൾക്കായി റിയൽ-ടൈം നോട്ടിഫിക്കേഷനുകൾ പിന്തുണയ്ക്കുന്നു:

```python
# ഉപകരണങ്ങൾ മാറുമ്പോൾ സെർവർ അറിയിപ്പ് അയയ്ക്കുന്നു
{
  "jsonrpc": "2.0",
  "method": "notifications/tools/list_changed"
}

# ഉപകരണങ്ങളുടെ പട്ടിക പുതുക്കാൻ ക്ലയന്റ് പ്രതികരിക്കുന്നു
await session.list_tools()  # പുതുക്കിയ ഉപകരണങ്ങൾ നേടുക
```

## ആരംഭിക്കാം: ഘട്ടം-ഘട്ടമായ മാർഗ്ഗനിർദ്ദേശം

### ഘട്ടം 1: പരിസ്ഥിതി സജ്ജീകരണം

ആവശ്യമായ ഡിപ്പെൻഡൻസികൾ ഇൻസ്റ്റാൾ ചെയ്യുക:  
```bash
pip install fastmcp mcp-python-client openai requests pyautogui Pillow
```

### ഘട്ടം 2: അടിസ്ഥാന കോൺഫിഗറേഷൻ

നിങ്ങളുടെ പരിസ്ഥിതി വേരിയബിളുകൾ സജ്ജീകരിക്കുക:  
```python
# സിസ്റ്റം കോൺഫിഗറേഷൻ
SYSTEM_PROMPT = "You are an AI assistant with some tools."

# ഒല്ലാമ കോൺഫിഗറേഷൻ (ലോകൽ)
OLLAMA_URL = "http://localhost:11434/api/chat"
OLLAMA_MODEL_ID = "phi4-mini:3.8b-fp16"

# vLLM കോൺഫിഗറേഷൻ (സർവർ)
VLLM_URL = "http://localhost:8000/v1"
VLLM_MODEL_ID = "microsoft/Phi-4-mini-instruct"
```

### ഘട്ടം 3: നിങ്ങളുടെ ആദ്യ MCP ക്ലയന്റ് പ്രവർത്തിപ്പിക്കൽ

**അടിസ്ഥാന ഒല്ലാമ സജ്ജീകരണം:**  
```bash
python ghmodel_mcp_demo.py
```

**vLLM ബാക്ക്എൻഡ് ഉപയോഗിക്കൽ:**  
```bash
python ghmodel_mcp_demo.py --env vllm
```

**സെർവർ-സെന്റ് ഇവന്റ്സ് കണക്ഷൻ:**  
```bash
python ghmodel_mcp_demo.py --run sse
```

**കസ്റ്റം MCP സെർവർ:**  
```bash
python ghmodel_mcp_demo.py --server /path/to/server.py
```

### ഘട്ടം 4: പ്രോഗ്രാമാറ്റിക് ഉപയോഗം

```python
import asyncio
from ghmodel_mcp_demo import OllamaClient, Phi4MiniMCPClient

async def automated_interaction():
    # MCP സെർവർ പാരാമീറ്ററുകൾ ക്രമീകരിക്കുക
    server_params = StdioServerParameters(
        command="npx",
        args=["@playwright/mcp@latest"],
        env=None,
    )
    
    # MCP ക്ലയന്റ് സൃഷ്ടിക്കുകയും ടൂൾസ് പ്രോസസ്സ് ചെയ്യുകയും ചെയ്യുക
    async with Phi4MiniMCPClient(server_params) as mcp_client:
        tools = await process_mcp_tools(mcp_client)
        llm_client = OllamaClient()
        
        # ടൂൾ കഴിവുകളോടെ പ്രതികരണം സൃഷ്ടിക്കുക
        response, messages = await llm_client.generate_response(
            "Help me automate a web task",
            tools
        )
        return response

# ഓട്ടോമേഷൻ നടപ്പിലാക്കുക
result = asyncio.run(automated_interaction())
print(result)
```

## പുരോഗമന ഫീച്ചറുകൾ

### മൾട്ടി-ബാക്ക്എൻഡ് പിന്തുണ

നടപ്പാക്കൽ ഒല്ലാമയും vLLM ബാക്ക്എൻഡുകളും പിന്തുണയ്ക്കുന്നു, നിങ്ങളുടെ ആവശ്യകതകൾ അനുസരിച്ച് തിരഞ്ഞെടുക്കാം:

- **ഒല്ലാമ**: ലോക്കൽ വികസനത്തിനും ടെസ്റ്റിംഗിനും ഉത്തമം  
- **vLLM**: പ്രൊഡക്ഷനും ഉയർന്ന ത്രൂപുട്ടിനും ഒപ്റ്റിമൈസ് ചെയ്തത്

### ഫ്ലെക്സിബിൾ കണക്ഷൻ പ്രോട്ടോക്കോളുകൾ

രണ്ട് കണക്ഷൻ മോഡുകൾ പിന്തുണയ്ക്കുന്നു:

**STDIO മോഡ്**: നേരിട്ടുള്ള പ്രോസസ് കമ്മ്യൂണിക്കേഷൻ  
- കുറഞ്ഞ ലാറ്റൻസി  
- ലോക്കൽ ടൂളുകൾക്ക് അനുയോജ്യം  
- ലളിതമായ സജ്ജീകരണം

**SSE മോഡ്**: HTTP അടിസ്ഥാനത്തിലുള്ള സ്ട്രീമിംഗ്  
- നെറ്റ്‌വർക്ക്-സാധ്യമായ  
- വിതരണ സിസ്റ്റങ്ങൾക്കായി ഉത്തമം  
- റിയൽ-ടൈം അപ്‌ഡേറ്റുകൾ

### ടൂൾ ഇന്റഗ്രേഷൻ കഴിവുകൾ

സിസ്റ്റം വിവിധ ടൂളുകളുമായി സംയോജിപ്പിക്കാം:  
- വെബ് ഓട്ടോമേഷൻ (Playwright)  
- ഫയൽ ഓപ്പറേഷനുകൾ  
- API ഇടപെടലുകൾ  
- സിസ്റ്റം കമാൻഡുകൾ  
- കസ്റ്റം ഫംഗ്ഷനുകൾ

## പിശക് കൈകാര്യം ചെയ്യലും മികച്ച പ്രാക്ടീസുകളും

### സമഗ്ര പിശക് മാനേജ്മെന്റ്

നടപ്പാക്കൽ ശക്തമായ പിശക് കൈകാര്യം ചെയ്യൽ ഉൾക്കൊള്ളുന്നു:

**കണക്ഷൻ പിശകുകൾ:**  
- MCP സെർവർ പരാജയങ്ങൾ  
- നെറ്റ്‌വർക്ക് ടൈംഔട്ടുകൾ  
- കണക്ടിവിറ്റി പ്രശ്നങ്ങൾ

**ടൂൾ എക്സിക്യൂഷൻ പിശകുകൾ:**  
- ടൂളുകൾ കാണാനാകാത്തത്  
- പാരാമീറ്റർ പരിശോധന  
- എക്സിക്യൂഷൻ പരാജയങ്ങൾ

**പ്രതികരണ പ്രോസസ്സിംഗ് പിശകുകൾ:**  
- JSON പാഴ്സിംഗ് പ്രശ്നങ്ങൾ  
- ഫോർമാറ്റ് അസമതുല്യതകൾ  
- LLM പ്രതികരണ അസാധാരണതകൾ

### മികച്ച പ്രാക്ടീസുകൾ

1. **റിസോഴ്‌സ് മാനേജ്മെന്റ്**: അസിങ്ക് കോൺടെക്സ്റ്റ് മാനേജർമാർ ഉപയോഗിക്കുക  
2. **പിശക് കൈകാര്യം ചെയ്യൽ**: സമഗ്രമായ ട്രൈ-കാച്ച് ബ്ലോക്കുകൾ നടപ്പിലാക്കുക  
3. **ലോഗിംഗ്**: അനുയോജ്യമായ ലോഗിംഗ് ലെവലുകൾ സജ്ജമാക്കുക  
4. **സുരക്ഷ**: ഇൻപുട്ടുകൾ പരിശോധിച്ച് ഔട്ട്പുട്ടുകൾ ശുദ്ധമാക്കുക  
5. **പ്രകടനം**: കണക്ഷൻ പൂളിംഗ്, കാഷിംഗ് ഉപയോഗിക്കുക

## യഥാർത്ഥ ലോക ആപ്ലിക്കേഷനുകൾ

### വെബ് ഓട്ടോമേഷൻ  
```python
# ഉദാഹരണം: സ്വയം പ്രവർത്തിക്കുന്ന വെബ് പരിശോധന
async def web_automation_example():
    tools = await setup_playwright_tools()
    response = await llm_client.generate_response(
        "Navigate to example.com and take a screenshot",
        tools
    )
```

### ഡാറ്റ പ്രോസസ്സിംഗ്  
```python
# ഉദാഹരണം: ഫയൽ വിശകലനം
async def data_processing_example():
    tools = await setup_file_tools()
    response = await llm_client.generate_response(
        "Analyze the CSV file and generate a summary report",
        tools
    )
```

### API ഇന്റഗ്രേഷൻ  
```python
# ഉദാഹരണം: API ഇടപെടലുകൾ
async def api_integration_example():
    tools = await setup_api_tools()
    response = await llm_client.generate_response(
        "Fetch weather data and create a forecast summary",
        tools
    )
```

## പ്രകടന മെച്ചപ്പെടുത്തൽ

### മെമ്മറി മാനേജ്മെന്റ്  
- കാര്യക്ഷമമായ സന്ദേശ ചരിത്ര കൈകാര്യം  
- ശരിയായ റിസോഴ്‌സ് ക്ലീനപ്പ്  
- കണക്ഷൻ പൂളിംഗ്

### നെറ്റ്‌വർക്ക് ഒപ്റ്റിമൈസേഷൻ  
- അസിങ്ക് HTTP ഓപ്പറേഷനുകൾ  
- ക്രമീകരിക്കാവുന്ന ടൈംഔട്ടുകൾ  
- സുന്ദരമായ പിശക് പുനരുദ്ധാരണം

### സമകാലിക പ്രോസസ്സിംഗ്  
- നോൺ-ബ്ലോക്കിംഗ് I/O  
- പാരലൽ ടൂൾ എക്സിക്യൂഷൻ  
- കാര്യക്ഷമമായ അസിങ്ക് പാറ്റേണുകൾ

## സുരക്ഷാ പരിഗണനകൾ

### ഡാറ്റ സംരക്ഷണം  
- സുരക്ഷിത API കീ മാനേജ്മെന്റ്  
- ഇൻപുട്ട് പരിശോധന  
- ഔട്ട്പുട്ട് ശുദ്ധീകരണം

### നെറ്റ്‌വർക്ക് സുരക്ഷ  
- HTTPS പിന്തുണ  
- ലോക്കൽ എൻഡ്‌പോയിന്റ് ഡിഫോൾട്ടുകൾ  
- സുരക്ഷിത ടോക്കൺ കൈകാര്യം

### എക്സിക്യൂഷൻ സുരക്ഷ  
- ടൂൾ ഫിൽട്ടറിംഗ്  
- സാൻഡ്‌ബോക്സ് പരിസ്ഥിതികൾ  
- ഓഡിറ്റ് ലോഗിംഗ്

## MCP ഇക്കോസിസ്റ്റവും വികസനവും

### MCP പ്രോജക്ട് പരിധി

Model Context Protocol ഇക്കോസിസ്റ്റത്തിൽ പ്രധാന ഘടകങ്ങൾ ഉൾപ്പെടുന്നു:

- **[MCP സ്പെസിഫിക്കേഷൻ](https://modelcontextprotocol.io/specification/latest)**: ക്ലയന്റുകളും സെർവറുകളും നടപ്പാക്കാനുള്ള ഔദ്യോഗിക നിർദ്ദേശങ്ങൾ  
- **[MCP SDKs](https://modelcontextprotocol.io/docs/sdk)**: MCP നടപ്പാക്കുന്ന വിവിധ പ്രോഗ്രാമിംഗ് ഭാഷകളുടെ SDKകൾ  
- MCP ഡെവലപ്പ്മെന്റ് ടൂളുകൾ: MCP സെർവറുകളും ക്ലയന്റുകളും വികസിപ്പിക്കാൻ, [MCP ഇൻസ്പെക്ടർ](https://github.com/modelcontextprotocol/inspector) ഉൾപ്പെടെ  
- **[MCP റഫറൻസ് സെർവർ നടപ്പാക്കലുകൾ](https://github.com/modelcontextprotocol/servers)**: MCP സെർവർ റഫറൻസ് നടപ്പാക്കലുകൾ

### MCP വികസനം ആരംഭിക്കുക

MCP ഉപയോഗിച്ച് നിർമ്മിക്കാൻ:

**സെർവർ നിർമ്മിക്കുക**: [MCP സെർവർ നിർമ്മിക്കുക](https://modelcontextprotocol.io/docs/develop/build-server) നിങ്ങളുടെ ഡാറ്റയും ടൂളുകളും തുറക്കാൻ

**ക്ലയന്റ് നിർമ്മിക്കുക**: [ആപ്ലിക്കേഷനുകൾ വികസിപ്പിക്കുക](https://modelcontextprotocol.io/docs/develop/build-client) MCP സെർവറുകളുമായി ബന്ധിപ്പിക്കാൻ

**അവബോധം നേടുക**: [MCPയുടെ കോർ ആശയങ്ങളും ആർക്കിടെക്ചറും](https://modelcontextprotocol.io/docs/learn/architecture) മനസിലാക്കുക

## സമാപനം

MCP-യുമായി സംയോജിപ്പിച്ച SLM-കൾ AI ആപ്ലിക്കേഷൻ വികസനത്തിൽ ഒരു പാരഡൈം മാറ്റമാണ്. ചെറിയ മോഡലുകളുടെ കാര്യക്ഷമതയും ബാഹ്യ ടൂളുകളുടെ ശക്തിയും ചേർന്ന്, ഡെവലപ്പർമാർ സ്രോതസ്സ് കാര്യക്ഷമവും വളരെ കഴിവുള്ളതുമായ ബുദ്ധിമുട്ടുള്ള സിസ്റ്റങ്ങൾ സൃഷ്ടിക്കാം.

Model Context Protocol AI ആപ്ലിക്കേഷനുകൾ ബാഹ്യ സിസ്റ്റങ്ങളുമായി ബന്ധിപ്പിക്കാൻ ഒരു സ്റ്റാൻഡേർഡ് മാർഗം നൽകുന്നു, USB-C ഇലക്ട്രോണിക് ഉപകരണങ്ങൾക്ക് സർവത്ര ബന്ധം നൽകുന്നതുപോലെ. ഈ സ്റ്റാൻഡർഡൈസേഷൻ സാധ്യമാക്കുന്നു:

- **സീംലെസ് ഇന്റഗ്രേഷൻ**: AI മോഡലുകൾ വ്യത്യസ്ത ഡാറ്റാ സ്രോതസ്സുകളുമായി ടൂളുകളുമായി ബന്ധിപ്പിക്കുക  
- **ഇക്കോസിസ്റ്റം വളർച്ച**: ഒരിക്കൽ നിർമ്മിച്ച് പല AI ആപ്ലിക്കേഷനുകളിലും ഉപയോഗിക്കുക  
- **ശക്തമായ കഴിവുകൾ**: SLM-കളെ ബാഹ്യ ഫംഗ്ഷണാലിറ്റിയോടെ വർദ്ധിപ്പിക്കുക  
- **റിയൽ-ടൈം അപ്‌ഡേറ്റുകൾ**: ഡൈനാമിക്, പ്രതികരണശീലമുള്ള AI ആപ്ലിക്കേഷനുകൾക്ക് പിന്തുണ

പ്രധാനപ്പെട്ട കാര്യങ്ങൾ:  
- MCP AI ആപ്ലിക്കേഷനുകളും ബാഹ്യ സിസ്റ്റങ്ങളുമായുള്ള പാലമാണ്  
- പ്രോട്ടോക്കോൾ ടൂളുകൾ, റിസോഴ്‌സുകൾ, പ്രോംപ്റ്റുകൾ കോർ പ്രിമിറ്റീവുകളായി പിന്തുണയ്ക്കുന്നു  
- റിയൽ-ടൈം നോട്ടിഫിക്കേഷനുകൾ ഡൈനാമിക്, പ്രതികരണശീലമുള്ള ആപ്ലിക്കേഷനുകൾക്ക് സഹായിക്കുന്നു  
- ശരിയായ ലൈഫ്‌സൈക്കിൾ മാനേജ്മെന്റും പിശക് കൈകാര്യം ചെയ്യലും പ്രൊഡക്ഷൻ ഉപയോഗത്തിന് അനിവാര്യമാണ്  
- ഇക്കോസിസ്റ്റം സമഗ്ര SDKകളും ഡെവലപ്പ്മെന്റ് ടൂളുകളും നൽകുന്നു

## റഫറൻസുകളും കൂടുതൽ വായനയും

### ഔദ്യോഗിക MCP ഡോക്യുമെന്റേഷൻ

- **[Model Context Protocol ഔദ്യോഗിക സൈറ്റ്](https://modelcontextprotocol.io/)** - സമ്പൂർണ്ണ ഡോക്യുമെന്റേഷൻ, സ്പെസിഫിക്കേഷനുകൾ  
- **[MCP ആരംഭിക്കൽ ഗൈഡ്](https://modelcontextprotocol.io/docs/getting-started/intro)** - പരിചയവും കോർ ആശയങ്ങളും  
- **[MCP ആർക്കിടെക്ചർ അവലോകനം](https://modelcontextprotocol.io/docs/learn/architecture)** - വിശദമായ സാങ്കേതിക ആർക്കിടെക്ചർ  
- **[MCP സ്പെസിഫിക്കേഷൻ](https://modelcontextprotocol.io/specification/latest)** - ഔദ്യോഗിക പ്രോട്ടോക്കോൾ സ്പെസിഫിക്കേഷൻ  
- **[MCP SDKs ഡോക്യുമെന്റേഷൻ](https://modelcontextprotocol.io/docs/sdk)** - ഭാഷാ-നിർദിഷ്ട SDK മാർഗ്ഗനിർദ്ദേശങ്ങൾ

### വികസന വിഭവങ്ങൾ

- **[MCP ആരംഭക്കാർക്ക്](https://aka.ms/mcp-for-beginners)** - Model Context Protocol-ന്റെ സമഗ്ര തുടക്ക ഗൈഡ്  
- **[MCP GitHub ഓർഗനൈസേഷൻ](https://github.com/modelcontextprotocol)** - ഔദ്യോഗിക റിപോസിറ്ററികളും ഉദാഹരണങ്ങളും  
- **[MCP സെർവർ റിപോസിറ്ററി](https://github.com/modelcontextprotocol/servers)** - റഫറൻസ് സെർവർ നടപ്പാക്കലുകൾ  
- **[MCP ഇൻസ്പെക്ടർ](https://github.com/modelcontextprotocol/inspector)** - ഡെവലപ്പ്മെന്റ്, ഡീബഗ്ഗിംഗ് ടൂൾ  
- **[MCP സെർവർ നിർമ്മാണ ഗൈഡ്](https://modelcontextprotocol.io/docs/develop/build-server)** - സെർവർ വികസന ട്യൂട്ടോറിയൽ  
- **[MCP ക്ലയന്റ് നിർമ്മാണ ഗൈഡ്](https://modelcontextprotocol.io/docs/develop/build-client)** - ക്ലയന്റ് വികസന ട്യൂട്ടോറിയൽ

### ചെറിയ ഭാഷാ മോഡലുകളും എഡ്ജ് AI-യും

- **[Microsoft Phi മോഡലുകൾ](https://aka.ms/phicookbook)** - Phi മോഡൽ കുടുംബം  
- **[Foundry Local ഡോക്യുമെന്റേഷൻ](https://github.com/microsoft/Foundry-Local)** - Microsoft-ന്റെ എഡ്ജ് AI റൺടൈം
- **[Ollama ഡോക്യുമെന്റേഷൻ](https://ollama.ai/docs)** - ലോക്കൽ LLM വിന്യാസ പ്ലാറ്റ്ഫോം  
- **[vLLM ഡോക്യുമെന്റേഷൻ](https://docs.vllm.ai/)** - ഉയർന്ന പ്രകടനക്ഷമതയുള്ള LLM സർവിംഗ്  

### സാങ്കേതിക മാനദണ്ഡങ്ങളും പ്രോട്ടോക്കോളുകളും

- **[JSON-RPC 2.0 സ്പെസിഫിക്കേഷൻ](https://www.jsonrpc.org/)** - MCP ഉപയോഗിക്കുന്ന അടിസ്ഥാന RPC പ്രോട്ടോക്കോൾ  
- **[JSON സ്കീമ](https://json-schema.org/)** - MCP ടൂളുകൾക്കുള്ള സ്കീമ നിർവചന മാനദണ്ഡം  
- **[OpenAPI സ്പെസിഫിക്കേഷൻ](https://swagger.io/specification/)** - API ഡോക്യുമെന്റേഷൻ മാനദണ്ഡം  
- **[സർവർ-സെന്റ് ഇവന്റ്സ് (SSE)](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events)** - റിയൽ-ടൈം അപ്‌ഡേറ്റുകൾക്കുള്ള വെബ് സ്റ്റാൻഡേർഡ്  

### AI ഏജന്റ് വികസനം

- **[Microsoft ഏജന്റ് ഫ്രെയിംവർക്ക്](https://github.com/microsoft/agent-framework)** - പ്രൊഡക്ഷൻ-റെഡി ഏജന്റ് വികസനം  
- **[LangChain ഡോക്യുമെന്റേഷൻ](https://docs.langchain.com/)** - ഏജന്റ്, ടൂൾ ഇന്റഗ്രേഷൻ ഫ്രെയിംവർക്ക്  
- **[സെമാന്റിക് കർണൽ](https://learn.microsoft.com/en-us/semantic-kernel/)** - മൈക്രോസോഫ്റ്റിന്റെ AI ഓർക്കസ്ട്രേഷൻ SDK  

### വ്യവസായ റിപ്പോർട്ടുകളും ഗവേഷണവും

- **[Anthropic-ന്റെ മോഡൽ കോൺടെക്സ്റ്റ് പ്രോട്ടോക്കോൾ പ്രഖ്യാപനം](https://www.anthropic.com/news/model-context-protocol)** - MCP യുടെ ആദ്യ പരിചയം  
- **[സ്മാൾ ലാംഗ്വേജ് മോഡലുകൾ സർവേ](https://arxiv.org/abs/2410.20011)** - SLM ഗവേഷണത്തിന്റെ അക്കാദമിക് സർവേ  
- **[എഡ്ജ് AI മാർക്കറ്റ് വിശകലനം](https://www.marketsandmarkets.com/Market-Reports/edge-ai-software-market-74385617.html)** - വ്യവസായ പ്രവണതകളും പ്രവചനങ്ങളും  
- **[AI ഏജന്റ് വികസന മികച്ച പ്രാക്ടീസുകൾ](https://arxiv.org/abs/2309.02427)** - ഏജന്റ് ആർക്കിടെക്ചറുകളിലെ ഗവേഷണം  

ഈ വിഭാഗം നിങ്ങളുടെ സ്വന്തം SLM-പവർഡ് MCP ആപ്ലിക്കേഷനുകൾ നിർമ്മിക്കുന്നതിനുള്ള അടിസ്ഥാനമാണ്, ഓട്ടോമേഷൻ, ഡാറ്റ പ്രോസസ്സിംഗ്, ബുദ്ധിമുട്ടുള്ള സിസ്റ്റം ഇന്റഗ്രേഷൻ എന്നിവയ്ക്ക് സാധ്യതകൾ തുറക്കുന്നു.  

## ➡️ അടുത്തത് എന്താണ്

- [Module 7. Edge AI സാമ്പിളുകൾ](../Module07/README.md)

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
**അസൂയാ**:  
ഈ രേഖ AI വിവർത്തന സേവനം [Co-op Translator](https://github.com/Azure/co-op-translator) ഉപയോഗിച്ച് വിവർത്തനം ചെയ്തതാണ്. നാം കൃത്യതയ്ക്ക് ശ്രമിച്ചെങ്കിലും, സ്വയം പ്രവർത്തിക്കുന്ന വിവർത്തനങ്ങളിൽ പിശകുകൾ അല്ലെങ്കിൽ തെറ്റുകൾ ഉണ്ടാകാമെന്ന് ദയവായി ശ്രദ്ധിക്കുക. അതിന്റെ മാതൃഭാഷയിലുള്ള യഥാർത്ഥ രേഖയാണ് പ്രാമാണികമായ ഉറവിടം എന്ന് പരിഗണിക്കേണ്ടതാണ്. നിർണായക വിവരങ്ങൾക്ക്, പ്രൊഫഷണൽ മനുഷ്യ വിവർത്തനം ശുപാർശ ചെയ്യപ്പെടുന്നു. ഈ വിവർത്തനത്തിന്റെ ഉപയോഗത്തിൽ നിന്നുണ്ടാകുന്ന ഏതെങ്കിലും തെറ്റിദ്ധാരണകൾക്കോ തെറ്റായ വ്യാഖ്യാനങ്ങൾക്കോ ഞങ്ങൾ ഉത്തരവാദികളല്ല.
<!-- CO-OP TRANSLATOR DISCLAIMER END -->