# Avsnitt 03 - Integration av Model Context Protocol (MCP)

## Introduktion till MCP (Model Context Protocol)

Model Context Protocol (MCP) är en öppen standard för att koppla AI-applikationer till externa system. Med MCP kan AI-applikationer som Claude eller ChatGPT ansluta till datakällor (t.ex. lokala filer, databaser), verktyg (t.ex. sökmotorer, kalkylatorer) och arbetsflöden (t.ex. specialiserade prompts)—vilket gör det möjligt för dem att få tillgång till viktig information och utföra uppgifter.

Tänk på MCP som en **USB-C-port för AI-applikationer**. Precis som USB-C erbjuder ett standardiserat sätt att ansluta elektroniska enheter, erbjuder MCP ett standardiserat sätt att ansluta AI-applikationer till externa system.

### Vad kan MCP möjliggöra?

MCP låser upp kraftfulla funktioner för AI-applikationer:

- **Personliga AI-assistenter**: Agenter kan få tillgång till din Google Kalender och Notion, och fungera som en mer personlig AI-assistent
- **Avancerad kodgenerering**: Claude Code kan skapa en hel webbapplikation baserad på en Figma-design
- **Integration av företagsdata**: Företagschatbotar kan ansluta till flera databaser inom en organisation, vilket gör det möjligt för användare att analysera data via chat
- **Kreativa arbetsflöden**: AI-modeller kan skapa 3D-designs i Blender och skriva ut dem med en 3D-skrivare
- **Tillgång till realtidsinformation**: Anslut till externa datakällor för uppdaterad information
- **Komplexa flerstegsoperationer**: Utför sofistikerade arbetsflöden som kombinerar flera verktyg och system

### Varför är MCP viktigt?

MCP ger fördelar över hela ekosystemet:

**För utvecklare**: MCP minskar utvecklingstid och komplexitet vid skapande eller integration av en AI-applikation eller agent.

**För AI-applikationer**: MCP ger tillgång till ett ekosystem av datakällor, verktyg och appar som förbättrar funktionaliteten och förbättrar användarupplevelsen.

**För slutanvändare**: MCP resulterar i mer kapabla AI-applikationer eller agenter som kan få tillgång till din data och vid behov utföra åtgärder åt dig.

## Små språkmodeller (SLMs) i MCP

Små språkmodeller representerar ett effektivt sätt att distribuera AI och erbjuder flera fördelar:

### Fördelar med SLMs
- **Resurseffektivitet**: Lägre krav på beräkningskapacitet
- **Snabbare svarstider**: Minskad latens för realtidsapplikationer  
- **Kostnadseffektivitet**: Minimala infrastrukturbehov
- **Integritet**: Kan köras lokalt utan dataöverföring
- **Anpassning**: Lättare att finjustera för specifika områden

### Varför SLMs fungerar bra med MCP

SLMs i kombination med MCP skapar en kraftfull kombination där modellens resonemangsförmåga förstärks av externa verktyg, vilket kompenserar för deras mindre parameterantal genom förbättrad funktionalitet.

## Översikt över Python MCP SDK

Python MCP SDK utgör grunden för att bygga MCP-aktiverade applikationer. SDK:n inkluderar:

- **Klientbibliotek**: För att ansluta till MCP-servrar
- **Serverramverk**: För att skapa anpassade MCP-servrar
- **Protokollhanterare**: För att hantera kommunikation
- **Verktygsintegration**: För att utföra externa funktioner

## Praktisk implementering: Phi-4 MCP-klient

Låt oss utforska en verklig implementering med Microsofts Phi-4 mini-modell integrerad med MCP-funktioner.

### Översikt över MCP-arkitektur

MCP följer en **klient-server-arkitektur** där en MCP-värd (en AI-applikation som Claude Code eller Claude Desktop) etablerar anslutningar till en eller flera MCP-servrar. MCP-värden gör detta genom att skapa en MCP-klient för varje MCP-server.

#### Viktiga deltagare

- **MCP-värd**: AI-applikationen som koordinerar och hanterar en eller flera MCP-klienter
- **MCP-klient**: En komponent som upprätthåller en anslutning till en MCP-server och hämtar kontext från en MCP-server för MCP-värden att använda
- **MCP-server**: Ett program som tillhandahåller kontext till MCP-klienter

#### Tvåskiktsarkitektur

MCP består av två distinkta lager:

**Datalager**: Definierar det JSON-RPC-baserade protokollet för klient-server-kommunikation, inklusive:
- Livscykelhantering (anslutningsinitialisering, kapacitetsförhandling)
- Grundläggande primitiva funktioner (verktyg, resurser, prompts)
- Klientfunktioner (sampling, elicitation, loggning)
- Hjälpfunktioner (notifikationer, framstegsspårning)

**Transportlager**: Definierar kommunikationsmekanismer och kanaler:
- **STDIO Transport**: Använder standard in-/utflödesströmmar för lokala processer (optimal prestanda, ingen nätverksbelastning)
- **Streamable HTTP Transport**: Använder HTTP POST med valfria server-sända händelser för fjärrservrar (stöder standard HTTP-autentisering)

```
┌─────────────────────────────────────┐
│           MCP Host                  │
│     (AI Application)                │
└─────────────────┬───────────────────┘
                  │
┌─────────────────┴───────────────────┐
│         MCP Client 1                │
│  ┌─────────────────────────────────┐ │
│  │        Data Layer               │ │
│  │  ├── Lifecycle Management       │ │
│  │  ├── Primitives (Tools/Resources)│ │
│  │  └── Notifications              │ │
│  └─────────────────────────────────┘ │
│  ┌─────────────────────────────────┐ │
│  │      Transport Layer           │ │
│  │  ├── STDIO Transport           │ │
│  │  └── HTTP Transport            │ │
│  └─────────────────────────────────┘ │
└─────────────────┬───────────────────┘
                  │
┌─────────────────┴───────────────────┐
│         MCP Server 1                │
│    (Local/Remote Context Provider)  │
└─────────────────────────────────────┘
```

### MCP:s grundläggande primitiva funktioner

MCP definierar primitiva funktioner som specificerar typer av kontextuell information som kan delas med AI-applikationer och vilka åtgärder som kan utföras.

#### Serverprimitiver

MCP definierar tre grundläggande primitiva funktioner som servrar kan exponera:

**Verktyg**: Utförbara funktioner som AI-applikationer kan anropa för att utföra åtgärder
- Exempel: filoperationer, API-anrop, databasfrågor
- Metoder: `tools/list`, `tools/call`
- Stöd för dynamisk upptäckt och utförande

**Resurser**: Datakällor som tillhandahåller kontextuell information till AI-applikationer
- Exempel: filinnehåll, databasposter, API-svar
- Metoder: `resources/list`, `resources/read`
- Möjliggör åtkomst till strukturerad data

**Prompts**: Återanvändbara mallar som hjälper till att strukturera interaktioner med språkmodeller
- Exempel: systemprompts, få-shot-exempel
- Metoder: `prompts/list`, `prompts/get`
- Standardiserar AI-interaktionsmönster

#### Klientprimitiver

MCP definierar också primitiva funktioner som klienter kan exponera för att möjliggöra rikare interaktioner:

**Sampling**: Tillåter servrar att begära språkmodellkompletteringar från klientens AI-applikation
- Metod: `sampling/complete`
- Möjliggör modelloberoende serverutveckling
- Ger åtkomst till värdens språkmodell

**Elicitation**: Tillåter servrar att begära ytterligare information från användare
- Metod: `elicitation/request`
- Möjliggör användarinteraktion och bekräftelse
- Stödjer dynamisk informationsinsamling

**Loggning**: Gör det möjligt för servrar att skicka loggmeddelanden till klienter
- Används för felsökning och övervakning
- Ger insyn i serveroperationer

### MCP-protokollets livscykel

#### Initialisering och kapacitetsförhandling

MCP är ett tillståndsbaserat protokoll som kräver livscykelhantering. Initialiseringsprocessen fyller flera kritiska syften:

1. **Protokollversionsförhandling**: Säkerställer att både klient och server använder kompatibla protokollversioner (t.ex. "2025-06-18")
2. **Kapacitetsupptäckt**: Varje part deklarerar stödda funktioner och primitiva funktioner
3. **Identitetsutbyte**: Tillhandahåller identifierings- och versionsinformation

```python
# Example initialization request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "initialize",
  "params": {
    "protocolVersion": "2025-06-18",
    "capabilities": {
      "elicitation": {},  # Client supports user interaction
      "sampling": {}      # Client can provide LLM completions
    },
    "clientInfo": {
      "name": "edge-ai-client",
      "version": "1.0.0"
    }
  }
}
```

#### Verktygsupptäckt och utförande

Efter initialisering kan klienter upptäcka och utföra verktyg:

```python
# Discover available tools
tools_response = await session.list_tools()

# Execute a tool
result = await session.call_tool(
    "weather_current",
    {
        "location": "San Francisco",
        "units": "imperial"
    }
)
```

#### Realtidsnotifikationer

MCP stöder realtidsnotifikationer för dynamiska uppdateringar:

```python
# Server sends notification when tools change
{
  "jsonrpc": "2.0",
  "method": "notifications/tools/list_changed"
}

# Client responds by refreshing tool list
await session.list_tools()  # Get updated tools
```

## Komma igång: Steg-för-steg-guide

### Steg 1: Miljöinställning

Installera nödvändiga beroenden:
```bash
pip install fastmcp mcp-python-client openai requests pyautogui Pillow
```

### Steg 2: Grundläggande konfiguration

Ställ in dina miljövariabler:
```python
# System Configuration
SYSTEM_PROMPT = "You are an AI assistant with some tools."

# Ollama Configuration (Local)
OLLAMA_URL = "http://localhost:11434/api/chat"
OLLAMA_MODEL_ID = "phi4-mini:3.8b-fp16"

# vLLM Configuration (Server)
VLLM_URL = "http://localhost:8000/v1"
VLLM_MODEL_ID = "microsoft/Phi-4-mini-instruct"
```

### Steg 3: Kör din första MCP-klient

**Grundläggande Ollama-inställning:**
```bash
python ghmodel_mcp_demo.py
```

**Använda vLLM-backend:**
```bash
python ghmodel_mcp_demo.py --env vllm
```

**Server-sända händelser-anslutning:**
```bash
python ghmodel_mcp_demo.py --run sse
```

**Anpassad MCP-server:**
```bash
python ghmodel_mcp_demo.py --server /path/to/server.py
```

### Steg 4: Programmerbar användning

```python
import asyncio
from ghmodel_mcp_demo import OllamaClient, Phi4MiniMCPClient

async def automated_interaction():
    # Configure MCP server parameters
    server_params = StdioServerParameters(
        command="npx",
        args=["@playwright/mcp@latest"],
        env=None,
    )
    
    # Create MCP client and process tools
    async with Phi4MiniMCPClient(server_params) as mcp_client:
        tools = await process_mcp_tools(mcp_client)
        llm_client = OllamaClient()
        
        # Generate response with tool capabilities
        response, messages = await llm_client.generate_response(
            "Help me automate a web task",
            tools
        )
        return response

# Execute the automation
result = asyncio.run(automated_interaction())
print(result)
```

## Avancerade funktioner

### Stöd för flera backend

Implementeringen stöder både Ollama och vLLM-backends, vilket gör det möjligt att välja baserat på dina behov:

- **Ollama**: Bättre för lokal utveckling och testning
- **vLLM**: Optimerad för produktion och hög genomströmning

### Flexibla anslutningsprotokoll

Två anslutningslägen stöds:

**STDIO-läge**: Direkt processkommunikation
- Lägre latens
- Lämplig för lokala verktyg
- Enkel inställning

**SSE-läge**: HTTP-baserad streaming
- Nätverkskapabel
- Bättre för distribuerade system
- Realtidsuppdateringar

### Verktygsintegreringsmöjligheter

Systemet kan integreras med olika verktyg:
- Webautomation (Playwright)
- Filoperationer
- API-interaktioner
- Systemkommandon
- Anpassade funktioner

## Felhantering och bästa praxis

### Omfattande felhantering

Implementeringen inkluderar robust felhantering för:

**Anslutningsfel:**
- MCP-serverfel
- Nätverkstidsgränser
- Anslutningsproblem

**Verktygsutförandefel:**
- Saknade verktyg
- Parameterverifiering
- Utförandefel

**Svarshanteringsfel:**
- JSON-parsningsproblem
- Formatinkonsekvenser
- LLM-svarsavvikelser

### Bästa praxis

1. **Resurshantering**: Använd asynkrona kontexthanterare
2. **Felhantering**: Implementera omfattande try-catch-block
3. **Loggning**: Aktivera lämpliga loggnivåer
4. **Säkerhet**: Validera indata och sanera utdata
5. **Prestanda**: Använd anslutningspoolning och caching

## Verkliga applikationer

### Webautomation
```python
# Example: Automated web testing
async def web_automation_example():
    tools = await setup_playwright_tools()
    response = await llm_client.generate_response(
        "Navigate to example.com and take a screenshot",
        tools
    )
```

### Databehandling
```python
# Example: File analysis
async def data_processing_example():
    tools = await setup_file_tools()
    response = await llm_client.generate_response(
        "Analyze the CSV file and generate a summary report",
        tools
    )
```

### API-integration
```python
# Example: API interactions
async def api_integration_example():
    tools = await setup_api_tools()
    response = await llm_client.generate_response(
        "Fetch weather data and create a forecast summary",
        tools
    )
```

## Prestandaoptimering

### Minneshantering
- Effektiv hantering av meddelandehistorik
- Korrekt resursrensning
- Anslutningspoolning

### Nätverksoptimering
- Asynkrona HTTP-operationer
- Konfigurerbara tidsgränser
- Smidig felåterhämtning

### Samtidig bearbetning
- Icke-blockerande I/O
- Parallell verktygsutförande
- Effektiva asynkrona mönster

## Säkerhetsöverväganden

### Dataskydd
- Säker hantering av API-nycklar
- Indatavalidering
- Utdatasanering

### Nätverkssäkerhet
- Stöd för HTTPS
- Lokala standardendpoints
- Säker tokenhantering

### Utförandesäkerhet
- Verktygsfiltrering
- Sandlådemiljöer
- Revisionsloggning

## MCP-ekosystem och utveckling

### MCP-projektets omfattning

Model Context Protocol-ekosystemet inkluderar flera nyckelkomponenter:

- **[MCP-specifikation](https://modelcontextprotocol.io/specification/latest)**: Officiell specifikation som beskriver implementeringskrav för klienter och servrar
- **[MCP SDKs](https://modelcontextprotocol.io/docs/sdk)**: SDKs för olika programmeringsspråk som implementerar MCP
- **MCP-utvecklingsverktyg**: Verktyg för att utveckla MCP-servrar och klienter, inklusive [MCP Inspector](https://github.com/modelcontextprotocol/inspector)
- **[MCP-referensserverimplementeringar](https://github.com/modelcontextprotocol/servers)**: Referensimplementeringar av MCP-servrar

### Komma igång med MCP-utveckling

För att börja bygga med MCP:

**Bygg servrar**: [Skapa MCP-servrar](https://modelcontextprotocol.io/docs/develop/build-server) för att exponera din data och dina verktyg

**Bygg klienter**: [Utveckla applikationer](https://modelcontextprotocol.io/docs/develop/build-client) som ansluter till MCP-servrar

**Lär dig koncept**: [Förstå kärnkoncepten](https://modelcontextprotocol.io/docs/learn/architecture) och MCP:s arkitektur

## Slutsats

SLMs integrerade med MCP representerar ett paradigmskifte inom utvecklingen av AI-applikationer. Genom att kombinera små modellers effektivitet med kraften hos externa verktyg kan utvecklare skapa intelligenta system som är både resurseffektiva och mycket kapabla.

Model Context Protocol erbjuder ett standardiserat sätt att ansluta AI-applikationer till externa system, precis som USB-C erbjuder en universell anslutningsstandard för elektroniska enheter. Denna standardisering möjliggör:

- **Smidig integration**: Koppla AI-modeller till olika datakällor och verktyg
- **Ekosystemtillväxt**: Bygg en gång, använd över flera AI-applikationer
- **Förbättrade funktioner**: Förstärk SLMs med extern funktionalitet
- **Realtidsuppdateringar**: Stöd för dynamiska, responsiva AI-applikationer

Viktiga insikter:
- MCP är en öppen standard som bygger broar mellan AI-applikationer och externa system
- Protokollet stöder verktyg, resurser och prompts som grundläggande primitiva funktioner
- Realtidsnotifikationer möjliggör dynamiska, responsiva applikationer
- Korrekt livscykelhantering och felhantering är avgörande för produktionsanvändning
- Ekosystemet erbjuder omfattande SDKs och utvecklingsverktyg

## Referenser och vidare läsning

### Officiell MCP-dokumentation

- **[Model Context Protocol Officiell Webbplats](https://modelcontextprotocol.io/)** - Komplett dokumentation och specifikationer
- **[MCP Komma igång-guide](https://modelcontextprotocol.io/docs/getting-started/intro)** - Introduktion och kärnkoncept
- **[MCP Arkitekturöversikt](https://modelcontextprotocol.io/docs/learn/architecture)** - Detaljerad teknisk arkitektur
- **[MCP-specifikation](https://modelcontextprotocol.io/specification/latest)** - Officiell protokollspecifikation
- **[MCP SDKs Dokumentation](https://modelcontextprotocol.io/docs/sdk)** - Språkspecifika SDK-guider

### Utvecklingsresurser

- **[MCP för nybörjare](https://aka.ms/mcp-for-beginners)** - Omfattande nybörjarguide till Model Context Protocol
- **[MCP GitHub-organisation](https://github.com/modelcontextprotocol)** - Officiella repositories och exempel
- **[MCP Server Repository](https://github.com/modelcontextprotocol/servers)** - Referensserverimplementeringar
- **[MCP Inspector](https://github.com/modelcontextprotocol/inspector)** - Utvecklings- och felsökningsverktyg
- **[Bygg MCP-servrar Guide](https://modelcontextprotocol.io/docs/develop/build-server)** - Serverutvecklingstutorial
- **[Bygg MCP-klienter Guide](https://modelcontextprotocol.io/docs/develop/build-client)** - Klientutvecklingstutorial

### Små språkmodeller och Edge AI

- **[Microsoft Phi-modeller](https://aka.ms/phicookbook)** - Phi-modellfamiljen 
- **[Foundry Local Dokumentation](https://github.com/microsoft/Foundry-Local)** - Microsofts edge AI-runtime
- **[Ollama Dokumentation](https://ollama.ai/docs)** - Plattform för lokal LLM-distribution
- **[vLLM Dokumentation](https://docs.vllm.ai/)** - Högpresterande LLM-tjänster

### Tekniska standarder och protokoll

- **[JSON-RPC 2.0 Specifikation](https://www.jsonrpc.org/)** - Underliggande RPC-protokoll som används av MCP
- **[JSON Schema](https://json-schema.org/)** - Standard för schemadefinition för MCP-verktyg
- **[OpenAPI Specifikation](https://swagger.io/specification/)** - Standard för API-dokumentation
- **[Server-Sent Events (SSE)](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events)** - Webbstandard för realtidsuppdateringar

### AI-agentutveckling

- **[Microsoft Agent Framework](https://github.com/microsoft/agent-framework)** - Produktionsklar agentutveckling
- **[LangChain Dokumentation](https://docs.langchain.com/)** - Ramverk för agent- och verktygsintegration
- **[Semantic Kernel](https://learn.microsoft.com/en-us/semantic-kernel/)** - Microsofts SDK för AI-orkestrering

### Branschrapporter och forskning

- **[Anthropics Model Context Protocol Announcement](https://www.anthropic.com/news/model-context-protocol)** - Ursprunglig MCP-introduktion
- **[Small Language Models Survey](https://arxiv.org/abs/2410.20011)** - Akademisk undersökning av SLM-forskning
- **[Edge AI Marknadsanalys](https://www.marketsandmarkets.com/Market-Reports/edge-ai-software-market-74385617.html)** - Branschtrender och prognoser
- **[AI-agentutvecklingens bästa praxis](https://arxiv.org/abs/2309.02427)** - Forskning om agentarkitekturer

Den här sektionen ger grunden för att bygga dina egna MCP-applikationer som drivs av SLM, och öppnar upp möjligheter för automatisering, databehandling och integration av intelligenta system.

## ➡️ Vad händer härnäst

- [Modul 7. Edge AI-exempel](../Module07/README.md)

---

**Ansvarsfriskrivning**:  
Detta dokument har översatts med hjälp av AI-översättningstjänsten [Co-op Translator](https://github.com/Azure/co-op-translator). Även om vi strävar efter noggrannhet, bör det noteras att automatiserade översättningar kan innehålla fel eller felaktigheter. Det ursprungliga dokumentet på dess ursprungliga språk bör betraktas som den auktoritativa källan. För kritisk information rekommenderas professionell mänsklig översättning. Vi ansvarar inte för eventuella missförstånd eller feltolkningar som uppstår vid användning av denna översättning.