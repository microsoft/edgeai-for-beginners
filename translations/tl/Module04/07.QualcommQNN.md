# Seksyon 7: Qualcomm QNN (Qualcomm Neural Network) Optimization Suite

## Talaan ng Nilalaman
1. [Panimula](../../../Module04)
2. [Ano ang Qualcomm QNN?](../../../Module04)
3. [Pag-install](../../../Module04)
4. [Mabilisang Gabay sa Pagsisimula](../../../Module04)
5. [Halimbawa: Pag-convert at Pag-optimize ng Mga Modelo gamit ang QNN](../../../Module04)
6. [Advanced na Paggamit](../../../Module04)
7. [Pinakamahusay na Praktika](../../../Module04)
8. [Pag-aayos ng Problema](../../../Module04)
9. [Karagdagang Mga Mapagkukunan](../../../Module04)

## Panimula

Ang Qualcomm QNN (Qualcomm Neural Network) ay isang komprehensibong AI inference framework na idinisenyo upang ma-maximize ang potensyal ng AI hardware accelerators ng Qualcomm, kabilang ang Hexagon NPU, Adreno GPU, at Kryo CPU. Kung ang target mo ay mga mobile device, edge computing platforms, o automotive systems, ang QNN ay nagbibigay ng mga optimized na kakayahan sa inference na gumagamit ng mga espesyal na AI processing units ng Qualcomm para sa pinakamataas na performance at enerhiya na kahusayan.

## Ano ang Qualcomm QNN?

Ang Qualcomm QNN ay isang unified AI inference framework na nagbibigay-daan sa mga developer na mag-deploy ng AI models nang epektibo sa heterogeneous computing architecture ng Qualcomm. Nagbibigay ito ng unified programming interface para ma-access ang Hexagon NPU (Neural Processing Unit), Adreno GPU, at Kryo CPU, na awtomatikong pumipili ng pinakamainam na processing unit para sa iba't ibang model layers at operations.

### Pangunahing Katangian

- **Heterogeneous Computing**: Unified na access sa NPU, GPU, at CPU na may awtomatikong workload distribution
- **Hardware-Aware Optimization**: Mga espesyal na optimizations para sa Qualcomm Snapdragon platforms
- **Suporta sa Quantization**: Advanced na INT8, INT16, at mixed-precision quantization techniques
- **Mga Tool sa Model Conversion**: Direktang suporta para sa TensorFlow, PyTorch, ONNX, at Caffe models
- **Edge AI Optimized**: Idinisenyo para sa mobile at edge deployment scenarios na may focus sa power efficiency

### Mga Benepisyo

- **Pinakamataas na Performance**: Gamitin ang mga espesyal na AI hardware para sa hanggang 15x na pagtaas sa performance
- **Enerhiya na Kahusayan**: Optimized para sa mga mobile at battery-powered na device na may intelligent power management
- **Mababang Latency**: Hardware-accelerated inference na may minimal na overhead para sa real-time applications
- **Scalable Deployment**: Mula sa smartphones hanggang sa automotive platforms sa ecosystem ng Qualcomm
- **Handa para sa Produksyon**: Framework na subok na ginagamit sa milyun-milyong deployed na device

## Pag-install

### Mga Kinakailangan

- Qualcomm QNN SDK (kailangan ng rehistrasyon sa Qualcomm)
- Python 3.7 o mas mataas
- Compatible na Qualcomm hardware o simulator
- Android NDK (para sa mobile deployment)
- Linux o Windows na development environment

### QNN SDK Setup

1. **Magrehistro at Mag-download**: Bisitahin ang Qualcomm Developer Network para magrehistro at mag-download ng QNN SDK
2. **I-extract ang SDK**: I-unpack ang QNN SDK sa iyong development directory
3. **I-set ang Environment Variables**: I-configure ang mga path para sa QNN tools at libraries

```bash
# Set QNN environment variables
export QNN_SDK_ROOT=/path/to/qnn-sdk
export PATH=$QNN_SDK_ROOT/bin:$PATH
export LD_LIBRARY_PATH=$QNN_SDK_ROOT/lib:$LD_LIBRARY_PATH
```

### Python Environment Setup

Gumawa at i-activate ang virtual environment:

```bash
# Create virtual environment
python -m venv qnn-env

# Activate virtual environment
# On Windows:
qnn-env\Scripts\activate
# On Linux:
source qnn-env/bin/activate
```

I-install ang mga kinakailangang Python packages:

```bash
pip install numpy tensorflow torch onnx
```

### I-verify ang Pag-install

```bash
# Check QNN tools availability
qnn-model-lib-generator --help
qnn-context-binary-generator --help
qnn-net-run --help
```

Kung matagumpay, makikita mo ang help information para sa bawat QNN tool.

## Mabilisang Gabay sa Pagsisimula

### Ang Iyong Unang Model Conversion

I-convert ang isang simpleng PyTorch model para tumakbo sa Qualcomm hardware:

```python
import torch
import torch.nn as nn
import numpy as np

# Define a simple model
class SimpleModel(nn.Module):
    def __init__(self):
        super(SimpleModel, self).__init__()
        self.conv1 = nn.Conv2d(3, 32, 3, padding=1)
        self.relu = nn.ReLU()
        self.conv2 = nn.Conv2d(32, 64, 3, padding=1)
        self.pool = nn.AdaptiveAvgPool2d((1, 1))
        self.fc = nn.Linear(64, 10)
    
    def forward(self, x):
        x = self.relu(self.conv1(x))
        x = self.relu(self.conv2(x))
        x = self.pool(x)
        x = x.view(x.size(0), -1)
        x = self.fc(x)
        return x

# Create and export model
model = SimpleModel()
model.eval()

# Create dummy input for tracing
dummy_input = torch.randn(1, 3, 224, 224)

# Export to ONNX
torch.onnx.export(
    model,
    dummy_input,
    "simple_model.onnx",
    export_params=True,
    opset_version=11,
    do_constant_folding=True,
    input_names=['input'],
    output_names=['output'],
    dynamic_axes={'input': {0: 'batch_size'},
                  'output': {0: 'batch_size'}}
)
```

### I-convert ang ONNX sa QNN Format

```bash
# Convert ONNX model to QNN model library
qnn-onnx-converter \
    --input_network simple_model.onnx \
    --output_path simple_model.cpp \
    --input_dim input 1,3,224,224 \
    --quantization_overrides quantization_config.json
```

### Bumuo ng QNN Model Library

```bash
# Compile model library
qnn-model-lib-generator \
    -c simple_model.cpp \
    -b simple_model.bin \
    -t x86_64-linux-clang \
    -l simple_model \
    -o simple_model_qnn.so
```

### Ano ang Ginagawa ng Proseso

Ang optimization workflow ay kinabibilangan ng: pag-convert ng orihinal na model sa ONNX format, pag-translate ng ONNX sa QNN intermediate representation, pag-aapply ng hardware-specific optimizations, at pagbuo ng compiled model library para sa deployment.

### Paliwanag ng Mga Pangunahing Parameter

- `--input_network`: Source ONNX model file
- `--output_path`: Generated C++ source file
- `--input_dim`: Input tensor dimensions para sa optimization
- `--quantization_overrides`: Custom quantization configuration
- `-t x86_64-linux-clang`: Target architecture at compiler

## Halimbawa: Pag-convert at Pag-optimize ng Mga Modelo gamit ang QNN

### Hakbang 1: Advanced Model Conversion na may Quantization

Narito kung paano mag-apply ng custom quantization sa conversion:

```json
// quantization_config.json
{
  "activation_encodings": {
    "conv1/Relu:0": {
      "bitwidth": 8,
      "max": 6.0,
      "min": 0.0,
      "scale": 0.023529,
      "offset": 0
    }
  },
  "param_encodings": {
    "conv1.weight": {
      "bitwidth": 8,
      "max": 2.5,
      "min": -2.5,
      "scale": 0.019608,
      "offset": 127
    }
  },
  "activation_bitwidth": 8,
  "param_bitwidth": 8,
  "bias_bitwidth": 32
}
```

I-convert gamit ang custom quantization:

```bash
qnn-onnx-converter \
    --input_network model.onnx \
    --output_path model_quantized.cpp \
    --input_dim input 1,3,224,224 \
    --quantization_overrides quantization_config.json \
    --target_device hexagon \
    --optimization_level high
```

### Hakbang 2: Multi-Backend Optimization

I-configure para sa heterogeneous execution sa NPU, GPU, at CPU:

```bash
# Generate model library with multiple backend support
qnn-model-lib-generator \
    -c model_quantized.cpp \
    -b model_quantized.bin \
    -t aarch64-android \
    -l model_optimized \
    -o model_optimized.so \
    --target_backends htp,gpu,cpu
```

### Hakbang 3: Gumawa ng Context Binary para sa Deployment

```bash
# Generate optimized context binary
qnn-context-binary-generator \
    --model model_optimized.so \
    --backend libQnnHtp.so \
    --output_dir ./context_binaries \
    --input_list input_data.txt \
    --optimization_level high
```

### Hakbang 4: Inference gamit ang QNN Runtime

```python
import ctypes
import numpy as np

# Load QNN library
qnn_lib = ctypes.CDLL('./libQnn.so')

class QNNInference:
    def __init__(self, model_path, backend='htp'):
        self.model_path = model_path
        self.backend = backend
        self.context = None
        self._initialize()
    
    def _initialize(self):
        # Initialize QNN runtime
        # Load model and create inference context
        pass
    
    def preprocess_input(self, data):
        # Quantize input data if needed
        if self.is_quantized:
            # Apply quantization parameters
            scale = self.input_scale
            offset = self.input_offset
            quantized = np.clip(
                np.round(data / scale + offset), 
                0, 255
            ).astype(np.uint8)
            return quantized
        return data.astype(np.float32)
    
    def inference(self, input_data):
        # Preprocess input
        processed_input = self.preprocess_input(input_data)
        
        # Run inference on Qualcomm hardware
        # This would call into QNN C++ API
        output = self._run_inference(processed_input)
        
        # Postprocess output
        return self.postprocess_output(output)
    
    def postprocess_output(self, output):
        # Dequantize output if needed
        if self.is_quantized:
            scale = self.output_scale
            offset = self.output_offset
            dequantized = (output.astype(np.float32) - offset) * scale
            return dequantized
        return output

# Usage
inference_engine = QNNInference("model_optimized.so", backend="htp")
result = inference_engine.inference(input_tensor)
print(f"Inference result: {result}")
```

### Output Structure

Pagkatapos ng optimization, ang iyong deployment directory ay maglalaman ng:

```
qnn_model/
├── model_optimized.so          # Compiled model library
├── context_binaries/           # Pre-compiled contexts
│   ├── htp_context.bin        # NPU context
│   ├── gpu_context.bin        # GPU context
│   └── cpu_context.bin        # CPU context
├── quantization_config.json   # Quantization parameters
└── input_specs.json          # Input/output specifications
```

## Advanced na Paggamit

### Custom Backend Configuration

I-configure ang mga specific backend optimizations:

```json
// backend_config.json
{
  "htp_config": {
    "device_id": 0,
    "performance_mode": "high_performance",
    "precision_mode": "int8",
    "vtcm_mb": 8,
    "enable_dma": true
  },
  "gpu_config": {
    "device_id": 0,
    "performance_mode": "sustained_high_performance",
    "precision_mode": "fp16",
    "enable_transform_optimization": true
  },
  "cpu_config": {
    "num_threads": 4,
    "performance_mode": "balanced",
    "enable_fast_math": true
  }
}
```

### Dynamic Quantization

Mag-apply ng quantization sa runtime para sa mas mahusay na accuracy:

```python
class DynamicQuantization:
    def __init__(self, model_path):
        self.model_path = model_path
        self.calibration_data = []
    
    def collect_statistics(self, calibration_dataset):
        """Collect activation statistics for quantization"""
        for data in calibration_dataset:
            # Run inference and collect activation ranges
            activations = self.forward_hooks(data)
            self.calibration_data.append(activations)
    
    def compute_quantization_params(self):
        """Compute optimal quantization parameters"""
        params = {}
        for layer_name, activations in self.calibration_data:
            min_val = np.min(activations)
            max_val = np.max(activations)
            
            # Compute scale and offset for INT8 quantization
            scale = (max_val - min_val) / 255.0
            offset = -min_val / scale
            
            params[layer_name] = {
                "scale": scale,
                "offset": int(offset),
                "min": min_val,
                "max": max_val
            }
        
        return params
    
    def apply_quantization(self, quantization_params):
        """Apply computed quantization parameters"""
        config = {
            "activation_encodings": {},
            "param_encodings": {}
        }
        
        for layer, params in quantization_params.items():
            config["activation_encodings"][layer] = {
                "bitwidth": 8,
                "scale": params["scale"],
                "offset": params["offset"],
                "min": params["min"],
                "max": params["max"]
            }
        
        return config
```

### Performance Profiling

I-monitor ang performance sa iba't ibang backends:

```python
import time
import psutil

class QNNProfiler:
    def __init__(self):
        self.metrics = {}
    
    def profile_inference(self, inference_func, input_data, num_runs=100):
        """Profile inference performance"""
        latencies = []
        cpu_usage = []
        memory_usage = []
        
        for i in range(num_runs):
            # Monitor system resources
            process = psutil.Process()
            cpu_before = process.cpu_percent()
            memory_before = process.memory_info().rss
            
            # Measure inference time
            start_time = time.perf_counter()
            result = inference_func(input_data)
            end_time = time.perf_counter()
            
            latency = (end_time - start_time) * 1000  # Convert to ms
            latencies.append(latency)
            
            # Collect resource usage
            cpu_after = process.cpu_percent()
            memory_after = process.memory_info().rss
            
            cpu_usage.append(cpu_after - cpu_before)
            memory_usage.append(memory_after - memory_before)
        
        return {
            "avg_latency_ms": np.mean(latencies),
            "p95_latency_ms": np.percentile(latencies, 95),
            "p99_latency_ms": np.percentile(latencies, 99),
            "throughput_fps": 1000 / np.mean(latencies),
            "avg_cpu_usage": np.mean(cpu_usage),
            "avg_memory_delta_mb": np.mean(memory_usage) / (1024 * 1024)
        }

# Usage
profiler = QNNProfiler()
htp_metrics = profiler.profile_inference(htp_inference, test_data)
gpu_metrics = profiler.profile_inference(gpu_inference, test_data)
cpu_metrics = profiler.profile_inference(cpu_inference, test_data)

print("HTP Performance:", htp_metrics)
print("GPU Performance:", gpu_metrics)
print("CPU Performance:", cpu_metrics)
```

### Automated Backend Selection

Mag-implement ng intelligent backend selection batay sa model characteristics:

```python
class BackendSelector:
    def __init__(self):
        self.backend_capabilities = {
            "htp": {
                "supported_ops": ["Conv2d", "Dense", "BatchNorm", "ReLU"],
                "max_tensor_size": 8 * 1024 * 1024,  # 8MB
                "preferred_precision": "int8",
                "power_efficiency": 0.9
            },
            "gpu": {
                "supported_ops": ["Conv2d", "Dense", "ReLU", "Softmax"],
                "max_tensor_size": 64 * 1024 * 1024,  # 64MB
                "preferred_precision": "fp16",
                "power_efficiency": 0.6
            },
            "cpu": {
                "supported_ops": ["*"],  # All operations
                "max_tensor_size": 512 * 1024 * 1024,  # 512MB
                "preferred_precision": "fp32",
                "power_efficiency": 0.4
            }
        }
    
    def select_optimal_backend(self, model_info, constraints):
        """Select optimal backend based on model and constraints"""
        scores = {}
        
        for backend, caps in self.backend_capabilities.items():
            score = 0
            
            # Check operation support
            if all(op in caps["supported_ops"] or "*" in caps["supported_ops"] 
                   for op in model_info["operations"]):
                score += 30
            
            # Check tensor size compatibility
            if model_info["max_tensor_size"] <= caps["max_tensor_size"]:
                score += 25
            
            # Power efficiency consideration
            if constraints.get("power_critical", False):
                score += caps["power_efficiency"] * 25
            
            # Performance preference
            if constraints.get("performance_critical", False):
                if backend == "htp":
                    score += 20
            
            scores[backend] = score
        
        return max(scores, key=scores.get)

# Usage
selector = BackendSelector()
model_info = {
    "operations": ["Conv2d", "ReLU", "Dense"],
    "max_tensor_size": 4 * 1024 * 1024,
    "precision": "int8"
}
constraints = {
    "power_critical": True,
    "performance_critical": True
}

optimal_backend = selector.select_optimal_backend(model_info, constraints)
print(f"Recommended backend: {optimal_backend}")
```

## Pinakamahusay na Praktika

### 1. Optimization ng Model Architecture
- **Layer Fusion**: Pagsamahin ang mga operations tulad ng Conv+BatchNorm+ReLU para sa mas mahusay na NPU utilization
- **Depth-wise Separable Convolutions**: Mas piliin ito kaysa sa standard convolutions para sa mobile deployment
- **Quantization-Friendly Designs**: Gumamit ng ReLU activations at iwasan ang mga operations na hindi maganda sa quantization

### 2. Quantization Strategy
- **Post-Training Quantization**: Simulan ito para sa mabilis na deployment
- **Calibration Dataset**: Gumamit ng representative data na sumasaklaw sa lahat ng input variations
- **Mixed Precision**: Gumamit ng INT8 para sa karamihan ng layers, panatilihin ang critical layers sa mas mataas na precision

### 3. Mga Alituntunin sa Backend Selection
- **NPU (HTP)**: Pinakamahusay para sa CNN workloads, quantized models, at power-sensitive applications
- **GPU**: Optimal para sa compute-intensive operations, mas malalaking models, at FP16 precision
- **CPU**: Fallback para sa mga unsupported operations at debugging

### 4. Optimization ng Performance
- **Batch Size**: Gumamit ng batch size 1 para sa real-time applications, mas malalaking batches para sa throughput
- **Input Preprocessing**: Bawasan ang data copying at conversion overhead
- **Context Reuse**: I-pre-compile ang contexts para maiwasan ang runtime compilation overhead

### 5. Pamamahala ng Memory
- **Tensor Allocation**: Gumamit ng static allocation kung maaari para maiwasan ang runtime overhead
- **Memory Pools**: Mag-implement ng custom memory pools para sa madalas na allocated tensors
- **Buffer Reuse**: I-reuse ang input/output buffers sa mga inference calls

### 6. Optimization ng Power
- **Performance Modes**: Gumamit ng tamang performance modes batay sa thermal constraints
- **Dynamic Frequency Scaling**: Payagan ang system na i-scale ang frequency batay sa workload
- **Idle State Management**: Maayos na i-release ang resources kapag hindi ginagamit

## Pag-aayos ng Problema

### Karaniwang Mga Isyu

#### 1. Mga Problema sa SDK Installation
```bash
# Verify QNN SDK installation
echo $QNN_SDK_ROOT
ls $QNN_SDK_ROOT/bin/qnn-*

# Check library dependencies
ldd $QNN_SDK_ROOT/lib/libQnn.so
```

#### 2. Mga Error sa Model Conversion
```bash
# Enable verbose logging
qnn-onnx-converter \
    --input_network model.onnx \
    --output_path model.cpp \
    --debug \
    --log_level verbose
```

#### 3. Mga Isyu sa Quantization
```python
# Validate quantization parameters
def validate_quantization_range(data, scale, offset, bitwidth=8):
    quantized = np.clip(
        np.round(data / scale + offset), 
        0, (2**bitwidth) - 1
    )
    dequantized = (quantized - offset) * scale
    mse = np.mean((data - dequantized) ** 2)
    print(f"Quantization MSE: {mse}")
    return mse < threshold
```

#### 4. Mga Problema sa Performance
```bash
# Check hardware utilization
adb shell cat /sys/class/devfreq/soc:qcom,cpu*-cpu-ddr-latfloor/cur_freq
adb shell cat /sys/class/kgsl/kgsl-3d0/gpuclk

# Monitor NPU usage
adb shell cat /sys/kernel/debug/msm_vidc/load
```

#### 5. Mga Isyu sa Memory
```python
# Monitor memory usage
import tracemalloc

tracemalloc.start()
# Run inference
result = inference_engine.inference(input_data)
current, peak = tracemalloc.get_traced_memory()
print(f"Current memory usage: {current / 1024 / 1024:.1f} MB")
print(f"Peak memory usage: {peak / 1024 / 1024:.1f} MB")
tracemalloc.stop()
```

#### 6. Backend Compatibility
```python
# Check backend availability
def check_backend_support():
    try:
        # Load backend library
        htp_lib = ctypes.CDLL('./libQnnHtp.so')
        print("HTP backend available")
    except OSError:
        print("HTP backend not available")
    
    try:
        gpu_lib = ctypes.CDLL('./libQnnGpu.so')
        print("GPU backend available")
    except OSError:
        print("GPU backend not available")
```

### Debugging ng Performance

```python
# Create performance analysis tool
class QNNDebugger:
    def __init__(self, model_path):
        self.model_path = model_path
        self.layer_timings = {}
    
    def profile_layers(self, input_data):
        """Profile individual layer performance"""
        # This would require integration with QNN profiling APIs
        for layer_name in self.get_layer_names():
            start = time.perf_counter()
            # Execute layer
            end = time.perf_counter()
            self.layer_timings[layer_name] = (end - start) * 1000
    
    def analyze_bottlenecks(self):
        """Identify performance bottlenecks"""
        sorted_layers = sorted(
            self.layer_timings.items(), 
            key=lambda x: x[1], 
            reverse=True
        )
        
        print("Top 5 slowest layers:")
        for layer, time_ms in sorted_layers[:5]:
            print(f"  {layer}: {time_ms:.2f} ms")
    
    def suggest_optimizations(self):
        """Suggest optimization strategies"""
        suggestions = []
        
        for layer, time_ms in self.layer_timings.items():
            if time_ms > 10:  # Layer takes more than 10ms
                if "conv" in layer.lower():
                    suggestions.append(f"Consider depthwise separable conv for {layer}")
                elif "dense" in layer.lower():
                    suggestions.append(f"Consider quantization for {layer}")
        
        return suggestions
```

### Pagkuha ng Tulong

- **Qualcomm Developer Network**: [developer.qualcomm.com](https://developer.qualcomm.com/)
- **QNN Documentation**: Available sa SDK package
- **Community Forums**: [developer.qualcomm.com/forums](https://developer.qualcomm.com/forums)
- **Technical Support**: Sa pamamagitan ng Qualcomm developer portal

## Karagdagang Mga Mapagkukunan

### Opisyal na Mga Link
- **Qualcomm AI Hub**: [aihub.qualcomm.com](https://aihub.qualcomm.com/)
- **Snapdragon Platforms**: [qualcomm.com/products/mobile/snapdragon](https://www.qualcomm.com/products/mobile/snapdragon)
- **Developer Portal**: [developer.qualcomm.com/software/qualcomm-neural-processing-sdk](https://developer.qualcomm.com/software/qualcomm-neural-processing-sdk)
- **AI Engine**: [qualcomm.com/news/onq/2019/06/qualcomm-ai-engine-direct](https://www.qualcomm.com/news/onq/2019/06/qualcomm-ai-engine-direct)

### Mga Mapagkukunan sa Pag-aaral
- **Getting Started Guide**: Available sa QNN SDK documentation
- **Model Zoo**: [aihub.qualcomm.com/models](https://aihub.qualcomm.com/models)
- **Optimization Guide**: Ang SDK documentation ay naglalaman ng komprehensibong optimization guidelines
- **Video Tutorials**: [Qualcomm Developer YouTube Channel](https://www.youtube.com/c/QualcommDeveloperNetwork)

### Mga Tool sa Integrasyon
- **SNPE (Legacy)**: [developer.qualcomm.com/docs/snpe](https://developer.qualcomm.com/docs/snpe/overview.html)
- **AI Hub**: Pre-optimized models para sa Qualcomm hardware
- **Android Neural Networks API**: Integrasyon sa Android NNAPI
- **TensorFlow Lite Delegate**: Qualcomm delegate para sa TFLite

### Mga Benchmark ng Performance
- **MLPerf Mobile**: [mlcommons.org/en/inference-mobile-21](https://mlcommons.org/en/inference-mobile-21/)
- **AI Benchmark**: [ai-benchmark.com/ranking](https://ai-benchmark.com/ranking.html)
- **Qualcomm AI Research**: [qualcomm.com/research/artificial-intelligence](https://www.qualcomm.com/research/artificial-intelligence)

### Mga Halimbawa ng Komunidad
- **Sample Applications**: Available sa QNN SDK examples directory
- **GitHub Repositories**: Mga halimbawa at tools na kontribusyon ng komunidad
- **Technical Blogs**: [Qualcomm Developer Blog](https://developer.qualcomm.com/blog)

### Kaugnay na Mga Tool
- **Qualcomm AI Model Efficiency Toolkit (AIMET)**: [github.com/quic/aimet](https://github.com/quic/aimet) - Advanced na quantization at compression techniques
- **TensorFlow Lite**: [tensorflow.org/lite](https://www.tensorflow.org/lite) - Para sa comparison at fallback deployment
- **ONNX Runtime**: [onnxruntime.ai](https://onnxruntime.ai/) - Cross-platform inference engine

### Mga Espesipikasyon ng Hardware
- **Hexagon NPU**: [developer.qualcomm.com/hardware/hexagon-dsp](https://developer.qualcomm.com/hardware/hexagon-dsp)
- **Adreno GPU**: [developer.qualcomm.com/hardware/adreno-gpu](https://developer.qualcomm.com/hardware/adreno-gpu)
- **Snapdragon Platforms**: [qualcomm.com/products/mobile/snapdragon](https://www.qualcomm.com/products/mobile/snapdragon)

## ➡️ Ano ang susunod

Ipagpatuloy ang iyong Edge AI journey sa pag-explore ng [Module 5: SLMOps and Production Deployment](../Module05/README.md) upang matutunan ang operational aspects ng Small Language Model lifecycle management.

---

**Paunawa**:  
Ang dokumentong ito ay isinalin gamit ang AI translation service [Co-op Translator](https://github.com/Azure/co-op-translator). Bagamat sinisikap naming maging tumpak, mangyaring tandaan na ang mga awtomatikong pagsasalin ay maaaring maglaman ng mga pagkakamali o hindi pagkakatugma. Ang orihinal na dokumento sa kanyang katutubong wika ang dapat ituring na mapagkakatiwalaang pinagmulan. Para sa mahalagang impormasyon, inirerekomenda ang propesyonal na pagsasalin ng tao. Hindi kami mananagot sa anumang hindi pagkakaunawaan o maling interpretasyon na dulot ng paggamit ng pagsasaling ito.