# 03 skyrius - Modelio konteksto protokolo (MCP) integracija

## Įvadas į MCP (Modelio konteksto protokolą)

Modelio konteksto protokolas (MCP) yra atvirojo kodo standartas, skirtas AI programoms prijungti prie išorinių sistemų. Naudojant MCP, AI programos, tokios kaip Claude ar ChatGPT, gali prisijungti prie duomenų šaltinių (pvz., vietinių failų, duomenų bazių), įrankių (pvz., paieškos variklių, skaičiuotuvų) ir darbo eigų (pvz., specializuotų užklausų), leidžiant joms pasiekti svarbią informaciją ir atlikti užduotis.

Galvokite apie MCP kaip apie **USB-C jungtį AI programoms**. Kaip USB-C suteikia standartizuotą būdą prijungti elektroninius įrenginius, MCP suteikia standartizuotą būdą prijungti AI programas prie išorinių sistemų.

### Ką MCP gali suteikti?

MCP atveria galingas galimybes AI programoms:

- **Personalizuoti AI asistentai**: Agentai gali pasiekti jūsų Google Calendar ir Notion, veikdami kaip labiau personalizuoti AI asistentai
- **Pažangi kodo generacija**: Claude Code gali sukurti visą interneto programą naudodamas Figma dizainą
- **Įmonių duomenų integracija**: Įmonių pokalbių robotai gali prisijungti prie kelių duomenų bazių organizacijoje, suteikdami vartotojams galimybę analizuoti duomenis per pokalbius
- **Kūrybinės darbo eigos**: AI modeliai gali kurti 3D dizainus Blender programoje ir atspausdinti juos 3D spausdintuvu
- **Prieiga prie realaus laiko informacijos**: Prisijungimas prie išorinių duomenų šaltinių, kad būtų galima gauti naujausią informaciją
- **Sudėtingos daugiapakopės operacijos**: Atlikti sudėtingas darbo eigas, derinant kelis įrankius ir sistemas

### Kodėl MCP yra svarbus?

MCP teikia naudą visai ekosistemai:

**Kūrėjams**: MCP sumažina kūrimo laiką ir sudėtingumą kuriant ar integruojant AI programą ar agentą.

**AI programoms**: MCP suteikia prieigą prie duomenų šaltinių, įrankių ir programų ekosistemos, kuri pagerina galimybes ir vartotojo patirtį.

**Galutiniams vartotojams**: MCP leidžia sukurti pajėgesnes AI programas ar agentus, kurie gali pasiekti jūsų duomenis ir prireikus atlikti veiksmus jūsų vardu.

## Maži kalbos modeliai (SLMs) MCP

Maži kalbos modeliai yra efektyvus AI diegimo būdas, siūlantis keletą privalumų:

### SLM privalumai
- **Resursų efektyvumas**: Mažesni skaičiavimo reikalavimai
- **Greitesnis atsakas**: Sumažinta delsė realaus laiko programoms  
- **Ekonomiškumas**: Minimalūs infrastruktūros poreikiai
- **Privatumas**: Gali veikti vietoje, be duomenų perdavimo
- **Pritaikymas**: Lengviau pritaikyti specifinėms sritims

### Kodėl SLM gerai veikia su MCP

SLM kartu su MCP sukuria galingą derinį, kur modelio loginiai gebėjimai yra sustiprinami išoriniais įrankiais, kompensuojant mažesnį parametrų skaičių per padidintas funkcijas.

## Python MCP SDK apžvalga

Python MCP SDK suteikia pagrindą kurti MCP palaikančias programas. SDK apima:

- **Kliento bibliotekas**: Prisijungimui prie MCP serverių
- **Serverio struktūrą**: Norint sukurti individualius MCP serverius
- **Protokolo tvarkytuvus**: Komunikacijos valdymui
- **Įrankių integraciją**: Išorinių funkcijų vykdymui

## Praktinis įgyvendinimas: Phi-4 MCP klientas

Pažvelkime į realaus pasaulio įgyvendinimą, naudojant Microsoft Phi-4 mini modelį, integruotą su MCP galimybėmis.

### MCP architektūros apžvalga

MCP naudoja **kliento-serverio architektūrą**, kur MCP šeimininkas (AI programa, pvz., Claude Code ar Claude Desktop) užmezga ryšius su vienu ar daugiau MCP serverių. MCP šeimininkas tai pasiekia sukuriant vieną MCP klientą kiekvienam MCP serveriui.

#### Pagrindiniai dalyviai

- **MCP šeimininkas**: AI programa, kuri koordinuoja ir valdo vieną ar kelis MCP klientus
- **MCP klientas**: Komponentas, palaikantis ryšį su MCP serveriu ir gaunantis kontekstą iš MCP serverio, kurį naudoja MCP šeimininkas
- **MCP serveris**: Programa, teikianti kontekstą MCP klientams

#### Dviejų sluoksnių architektūra

MCP susideda iš dviejų atskirų sluoksnių:

**Duomenų sluoksnis**: Apibrėžia JSON-RPC pagrįstą protokolą klientų-serverių komunikacijai, įskaitant:
- Gyvavimo ciklo valdymą (ryšio inicializavimas, galimybių derinimas)
- Pagrindinius elementus (įrankius, išteklius, užklausas)
- Kliento funkcijas (pavyzdžių paėmimas, informacijos rinkimas, registravimas)
- Naudingas funkcijas (pranešimai, pažangos stebėjimas)

**Transporto sluoksnis**: Apibrėžia komunikacijos mechanizmus ir kanalus:
- **STDIO transportas**: Naudoja standartinius įvesties/išvesties srautus vietiniams procesams (optimalus našumas, nėra tinklo apkrovos)
- **Streamable HTTP transportas**: Naudoja HTTP POST su pasirenkamais serverio siunčiamais įvykiais nuotoliniams serveriams (palaiko standartinę HTTP autentifikaciją)

```
┌─────────────────────────────────────┐
│           MCP Host                  │
│     (AI Application)                │
└─────────────────┬───────────────────┘
                  │
┌─────────────────┴───────────────────┐
│         MCP Client 1                │
│  ┌─────────────────────────────────┐ │
│  │        Data Layer               │ │
│  │  ├── Lifecycle Management       │ │
│  │  ├── Primitives (Tools/Resources)│ │
│  │  └── Notifications              │ │
│  └─────────────────────────────────┘ │
│  ┌─────────────────────────────────┐ │
│  │      Transport Layer           │ │
│  │  ├── STDIO Transport           │ │
│  │  └── HTTP Transport            │ │
│  └─────────────────────────────────┘ │
└─────────────────┬───────────────────┘
                  │
┌─────────────────┴───────────────────┐
│         MCP Server 1                │
│    (Local/Remote Context Provider)  │
└─────────────────────────────────────┘
```

### MCP pagrindiniai elementai

MCP apibrėžia elementus, kurie nurodo kontekstinės informacijos tipus, kuriuos galima dalintis su AI programomis, ir veiksmų, kuriuos galima atlikti, diapazoną.

#### Serverio elementai

MCP apibrėžia tris pagrindinius elementus, kuriuos serveriai gali pateikti:

**Įrankiai**: Vykdomos funkcijos, kurias AI programos gali iškviesti veiksmams atlikti
- Pavyzdžiai: failų operacijos, API užklausos, duomenų bazės užklausos
- Metodai: `tools/list`, `tools/call`
- Palaiko dinaminį atradimą ir vykdymą

**Ištekliai**: Duomenų šaltiniai, teikiantys kontekstinę informaciją AI programoms
- Pavyzdžiai: failų turinys, duomenų bazės įrašai, API atsakymai
- Metodai: `resources/list`, `resources/read`
- Leidžia pasiekti struktūrizuotus duomenis

**Užklausos**: Naudojamos šablonai, padedantys struktūrizuoti sąveiką su kalbos modeliais
- Pavyzdžiai: sistemos užklausos, kelių pavyzdžių užklausos
- Metodai: `prompts/list`, `prompts/get`
- Standartizuoja AI sąveikos modelius

#### Kliento elementai

MCP taip pat apibrėžia elementus, kuriuos klientai gali pateikti, kad būtų galima praturtinti sąveiką:

**Pavyzdžių paėmimas**: Leidžia serveriams prašyti kalbos modelio užbaigimų iš kliento AI programos
- Metodas: `sampling/complete`
- Leidžia modelio nepriklausomą serverio kūrimą
- Suteikia prieigą prie šeimininko kalbos modelio

**Informacijos rinkimas**: Leidžia serveriams prašyti papildomos informacijos iš vartotojų
- Metodas: `elicitation/request`
- Leidžia vartotojų sąveiką ir patvirtinimą
- Palaiko dinaminį informacijos rinkimą

**Registravimas**: Leidžia serveriams siųsti registracijos pranešimus klientams
- Naudojamas derinimui ir stebėjimui
- Suteikia matomumą serverio operacijoms

### MCP protokolo gyvavimo ciklas

#### Inicializavimas ir galimybių derinimas

MCP yra būseninis protokolas, reikalaujantis gyvavimo ciklo valdymo. Inicializavimo procesas atlieka kelias svarbias funkcijas:

1. **Protokolo versijos derinimas**: Užtikrina, kad klientas ir serveris naudotų suderinamas protokolo versijas (pvz., "2025-06-18")
2. **Galimybių atradimas**: Kiekviena šalis deklaruoja palaikomas funkcijas ir elementus
3. **Identifikacijos apsikeitimas**: Suteikia identifikacijos ir versijos informaciją

```python
# Example initialization request
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "initialize",
  "params": {
    "protocolVersion": "2025-06-18",
    "capabilities": {
      "elicitation": {},  # Client supports user interaction
      "sampling": {}      # Client can provide LLM completions
    },
    "clientInfo": {
      "name": "edge-ai-client",
      "version": "1.0.0"
    }
  }
}
```

#### Įrankių atradimas ir vykdymas

Po inicializavimo klientai gali atrasti ir vykdyti įrankius:

```python
# Discover available tools
tools_response = await session.list_tools()

# Execute a tool
result = await session.call_tool(
    "weather_current",
    {
        "location": "San Francisco",
        "units": "imperial"
    }
)
```

#### Realiojo laiko pranešimai

MCP palaiko realiojo laiko pranešimus dinamiškiems atnaujinimams:

```python
# Server sends notification when tools change
{
  "jsonrpc": "2.0",
  "method": "notifications/tools/list_changed"
}

# Client responds by refreshing tool list
await session.list_tools()  # Get updated tools
```

## Pradžia: žingsnis po žingsnio vadovas

### 1 žingsnis: Aplinkos paruošimas

Įdiekite reikalingas priklausomybes:
```bash
pip install fastmcp mcp-python-client openai requests pyautogui Pillow
```

### 2 žingsnis: Pagrindinė konfigūracija

Nustatykite aplinkos kintamuosius:
```python
# System Configuration
SYSTEM_PROMPT = "You are an AI assistant with some tools."

# Ollama Configuration (Local)
OLLAMA_URL = "http://localhost:11434/api/chat"
OLLAMA_MODEL_ID = "phi4-mini:3.8b-fp16"

# vLLM Configuration (Server)
VLLM_URL = "http://localhost:8000/v1"
VLLM_MODEL_ID = "microsoft/Phi-4-mini-instruct"
```

### 3 žingsnis: Pirmojo MCP kliento paleidimas

**Pagrindinis Ollama nustatymas:**
```bash
python ghmodel_mcp_demo.py
```

**Naudojant vLLM pagrindą:**
```bash
python ghmodel_mcp_demo.py --env vllm
```

**Serverio siunčiamų įvykių ryšys:**
```bash
python ghmodel_mcp_demo.py --run sse
```

**Individualus MCP serveris:**
```bash
python ghmodel_mcp_demo.py --server /path/to/server.py
```

### 4 žingsnis: Programinis naudojimas

```python
import asyncio
from ghmodel_mcp_demo import OllamaClient, Phi4MiniMCPClient

async def automated_interaction():
    # Configure MCP server parameters
    server_params = StdioServerParameters(
        command="npx",
        args=["@playwright/mcp@latest"],
        env=None,
    )
    
    # Create MCP client and process tools
    async with Phi4MiniMCPClient(server_params) as mcp_client:
        tools = await process_mcp_tools(mcp_client)
        llm_client = OllamaClient()
        
        # Generate response with tool capabilities
        response, messages = await llm_client.generate_response(
            "Help me automate a web task",
            tools
        )
        return response

# Execute the automation
result = asyncio.run(automated_interaction())
print(result)
```

## Pažangios funkcijos

### Daugiapagrindės palaikymas

Įgyvendinimas palaiko tiek Ollama, tiek vLLM pagrindus, leidžiant pasirinkti pagal jūsų poreikius:

- **Ollama**: Geriau vietiniam kūrimui ir testavimui
- **vLLM**: Optimizuotas gamybai ir didelio našumo scenarijams

### Lankstūs ryšio protokolai

Palaikomi du ryšio režimai:

**STDIO režimas**: Tiesioginė procesų komunikacija
- Mažesnė delsė
- Tinka vietiniams įrankiams
- Paprastas nustatymas

**SSE režimas**: HTTP pagrįstas srautas
- Tinklo galimybės
- Geriau paskirstytoms sistemoms
- Realiojo laiko atnaujinimai

### Įrankių integracijos galimybės

Sistema gali integruotis su įvairiais įrankiais:
- Interneto automatizavimas (Playwright)
- Failų operacijos
- API sąveika
- Sistemos komandos
- Individualios funkcijos

## Klaidų valdymas ir geriausia praktika

### Išsamus klaidų valdymas

Įgyvendinimas apima patikimą klaidų valdymą:

**Ryšio klaidos:**
- MCP serverio gedimai
- Tinklo laiko limitai
- Ryšio problemos

**Įrankių vykdymo klaidos:**
- Trūkstami įrankiai
- Parametrų validacija
- Vykdymo gedimai

**Atsakymų apdorojimo klaidos:**
- JSON analizės problemos
- Formatų neatitikimai
- LLM atsakymų anomalijos

### Geriausia praktika

1. **Išteklių valdymas**: Naudokite asinchroninius konteksto valdytojus
2. **Klaidų valdymas**: Įgyvendinkite išsamius try-catch blokus
3. **Registravimas**: Įjunkite tinkamus registravimo lygius
4. **Saugumas**: Validuokite įvestis ir išvalykite išvestis
5. **Našumas**: Naudokite ryšio telkimą ir talpyklą

## Realūs pritaikymai

### Interneto automatizavimas
```python
# Example: Automated web testing
async def web_automation_example():
    tools = await setup_playwright_tools()
    response = await llm_client.generate_response(
        "Navigate to example.com and take a screenshot",
        tools
    )
```

### Duomenų apdorojimas
```python
# Example: File analysis
async def data_processing_example():
    tools = await setup_file_tools()
    response = await llm_client.generate_response(
        "Analyze the CSV file and generate a summary report",
        tools
    )
```

### API integracija
```python
# Example: API interactions
async def api_integration_example():
    tools = await setup_api_tools()
    response = await llm_client.generate_response(
        "Fetch weather data and create a forecast summary",
        tools
    )
```

## Našumo optimizavimas

### Atminties valdymas
- Efektyvus pranešimų istorijos tvarkymas
- Tinkamas išteklių išvalymas
- Ryšio telkimas

### Tinklo optimizavimas
- Asinchroninės HTTP operacijos
- Konfigūruojami laiko limitai
- Sklandus klaidų atkūrimas

### Lygiagretus apdorojimas
- Neužblokuojantis I/O
- Lygiagretus įrankių vykdymas
- Efektyvūs asinchroniniai modeliai

## Saugumo aspektai

### Duomenų apsauga
- Saugus API raktų valdymas
- Įvesties validacija
- Išvesties išvalymas

### Tinklo saugumas
- HTTPS palaikymas
- Vietinių galinių taškų numatytosios reikšmės
- Saugus žetonų valdymas

### Vykdymo saugumas
- Įrankių filtravimas
- Smėlio dėžės aplinkos
- Audito registravimas

## MCP ekosistema ir kūrimas

### MCP projekto apimtis

Modelio konteksto protokolo ekosistema apima kelis pagrindinius komponentus:

- **[MCP specifikacija](https://modelcontextprotocol.io/specification/latest)**: Oficialus specifikacijos dokumentas, apibrėžiantis klientų ir serverių įgyvendinimo reikalavimus
- **[MCP SDKs](https://modelcontextprotocol.io/docs/sdk)**: SDK įvairioms programavimo kalboms, įgyvendinančios MCP
- **MCP kūrimo įrankiai**: Įrankiai MCP serverių ir klientų kūrimui, įskaitant [MCP Inspector](https://github.com/modelcontextprotocol/inspector)
- **[MCP pavyzdiniai serverių įgyvendinimai](https://github.com/modelcontextprotocol/servers)**: Pavyzdiniai MCP serverių įgyvendinimai

### Pradžia su MCP kūrimu

Norėdami pradėti kurti su MCP:

**Kurti serverius**: [Sukurkite MCP serverius](https://modelcontextprotocol.io/docs/develop/build-server), kad galėtumėte pateikti savo duomenis ir įrankius

**Kurti klientus**: [Plėtokite programas](https://modelcontextprotocol.io/docs/develop/build-client), kurios jungiasi prie MCP serverių

**Suprasti koncepcijas**: [Supraskite pagrindines koncepcijas](https://modelcontextprotocol.io/docs/learn/architecture) ir MCP architektūrą

## Išvada

SLM, integruoti su MCP, atspindi paradigmos pokytį AI programų kūrime. Derinant mažų modelių efektyvumą su išorinių įrankių galia, kūrėjai gali kurti intelektualias sistemas, kurios yra tiek resursų efektyvios, tiek labai pajėgios.

Modelio konteksto protokolas suteikia standartizuotą būdą prijungti AI programas prie išorinių sistemų, kaip USB-C suteikia universalų jungties standartą elektroniniams įrenginiams. Ši standartizacija leidžia:

- **Sklandžią integraciją**: Prijungti AI modelius prie įvairių duomenų šaltinių ir įrankių
- **Ekosistemos augimą**: Sukurti vieną kartą, naudoti keliose AI programose
- **Padidintas galimybes**: Papildyti SLM išorinėmis funkcijomis
- **Realiojo laiko atnaujinimus**: Palaikyti dinamiškas, reaguojančias AI programas

Pagrindinės išvados:
- MCP yra atviras standartas, jungiantis AI programas ir išorines sistemas
- Protokolas palaiko įrankius, išteklius ir užklausas kaip pagrindinius elementus
- Realiojo laiko pranešimai leidžia dinamiškas, reaguojančias programas
- Tinkamas gyvavimo ciklo valdymas ir klaidų valdymas yra būtini gamybos naudojimui
- Ekosistema siūlo išs
- **[Ollama Dokumentacija](https://ollama.ai/docs)** - Vietinė LLM diegimo platforma  
- **[vLLM Dokumentacija](https://docs.vllm.ai/)** - Aukštos našumo LLM aptarnavimas  

### Techniniai standartai ir protokolai  

- **[JSON-RPC 2.0 Specifikacija](https://www.jsonrpc.org/)** - Pagrindinis RPC protokolas, naudojamas MCP  
- **[JSON Schema](https://json-schema.org/)** - Schemos apibrėžimo standartas MCP įrankiams  
- **[OpenAPI Specifikacija](https://swagger.io/specification/)** - API dokumentacijos standartas  
- **[Server-Sent Events (SSE)](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events)** - Tinklo standartas realaus laiko atnaujinimams  

### AI agentų kūrimas  

- **[Microsoft Agent Framework](https://github.com/microsoft/agent-framework)** - Paruoštas gamybai agentų kūrimas  
- **[LangChain Dokumentacija](https://docs.langchain.com/)** - Agentų ir įrankių integracijos sistema  
- **[Semantic Kernel](https://learn.microsoft.com/en-us/semantic-kernel/)** - Microsoft AI orkestravimo SDK  

### Pramonės ataskaitos ir tyrimai  

- **[Anthropic Model Context Protocol Pranešimas](https://www.anthropic.com/news/model-context-protocol)** - Pradinis MCP pristatymas  
- **[Mažų Kalbos Modelių Apžvalga](https://arxiv.org/abs/2410.20011)** - Akademinė SLM tyrimų apžvalga  
- **[Edge AI Rinkos Analizė](https://www.marketsandmarkets.com/Market-Reports/edge-ai-software-market-74385617.html)** - Pramonės tendencijos ir prognozės  
- **[AI Agentų Kūrimo Geriausios Praktikos](https://arxiv.org/abs/2309.02427)** - Tyrimai apie agentų architektūras  

Ši dalis suteikia pagrindą kurti savo SLM pagrįstas MCP programas, atveriant galimybes automatizavimui, duomenų apdorojimui ir intelektualiai sistemų integracijai.  

## ➡️ Kas toliau  

- [7 modulis. Edge AI pavyzdžiai](../Module07/README.md)  

---

**Atsakomybės apribojimas**:  
Šis dokumentas buvo išverstas naudojant AI vertimo paslaugą [Co-op Translator](https://github.com/Azure/co-op-translator). Nors siekiame tikslumo, prašome atkreipti dėmesį, kad automatiniai vertimai gali turėti klaidų ar netikslumų. Originalus dokumentas jo gimtąja kalba turėtų būti laikomas autoritetingu šaltiniu. Kritinei informacijai rekomenduojama profesionali žmogaus vertimo paslauga. Mes neprisiimame atsakomybės už nesusipratimus ar neteisingus aiškinimus, atsiradusius naudojant šį vertimą.