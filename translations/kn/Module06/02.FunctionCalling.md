<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "8b05633cf46af274b3724ee2f7140100",
  "translation_date": "2025-12-15T22:04:35+00:00",
  "source_file": "Module06/02.FunctionCalling.md",
  "language_code": "kn"
}
-->
# Section02 : ಸಣ್ಣ ಭಾಷಾ ಮಾದರಿಗಳಲ್ಲಿ (SLMs) ಫಂಕ್ಷನ್ ಕಾಲಿಂಗ್

## ವಿಷಯಗಳ ಪಟ್ಟಿಕೆ
1. [ಫಂಕ್ಷನ್ ಕಾಲಿಂಗ್ ಎಂದರೆ ಏನು?](../../../Module06)
2. [ಫಂಕ್ಷನ್ ಕಾಲಿಂಗ್ ಹೇಗೆ ಕಾರ್ಯನಿರ್ವಹಿಸುತ್ತದೆ](../../../Module06)
3. [ಅನ್ವಯಿಕೆ ದೃಶ್ಯಗಳು](../../../Module06)
4. [Phi-4-mini ಮತ್ತು Ollama ಜೊತೆಗೆ ಫಂಕ್ಷನ್ ಕಾಲಿಂಗ್ ಸೆಟ್‌ಅಪ್ ಮಾಡುವುದು](../../../Module06)
5. [Qwen3 ಫಂಕ್ಷನ್ ಕಾಲಿಂಗ್ ಜೊತೆಗೆ ಕೆಲಸ ಮಾಡುವುದು](../../../Module06)
6. [Foundry Local ಏಕೀಕರಣ](../../../Module06)
7. [ಉತ್ತಮ ಅಭ್ಯಾಸಗಳು ಮತ್ತು ಸಮಸ್ಯೆ ಪರಿಹಾರ](../../../Module06)
8. [ಅಧಿಕೃತ ಉದಾಹರಣೆಗಳು](../../../Module06)

## ಫಂಕ್ಷನ್ ಕಾಲಿಂಗ್ ಎಂದರೆ ಏನು?

ಫಂಕ್ಷನ್ ಕಾಲಿಂಗ್ ಎಂಬುದು ಶಕ್ತಿಶಾಲಿ ಸಾಮರ್ಥ್ಯವಾಗಿದ್ದು, ಸಣ್ಣ ಭಾಷಾ ಮಾದರಿಗಳು (SLMs) ಹೊರಗಿನ ಸಾಧನಗಳು, APIಗಳು ಮತ್ತು ಸೇವೆಗಳೊಂದಿಗೆ ಸಂವಹನ ಮಾಡಲು ಅನುಮತಿಸುತ್ತದೆ. ತಮ್ಮ ತರಬೇತಿ ಡೇಟಾದಲ್ಲಿ ಸೀಮಿತವಾಗಿರುವ ಬದಲು, SLMಗಳು ಈಗ:

- **ಹೊರಗಿನ APIಗಳಿಗೆ ಸಂಪರ್ಕಿಸುವುದು** (ಹವಾಮಾನ ಸೇವೆಗಳು, ಡೇಟಾಬೇಸ್‌ಗಳು, ಹುಡುಕಾಟ ಎಂಜಿನ್‌ಗಳು)
- **ಬಳಕೆದಾರರ ವಿನಂತಿಗಳ ಆಧಾರದ ಮೇಲೆ ನಿರ್ದಿಷ್ಟ ಫಂಕ್ಷನ್‌ಗಳನ್ನು ಕಾರ್ಯಗತಗೊಳಿಸುವುದು**
- **ವಿವಿಧ ಮೂಲಗಳಿಂದ ನೈಜ-ಸಮಯ ಮಾಹಿತಿ ಪಡೆಯುವುದು**
- **ವಿಶೇಷ ಸಾಧನಗಳ ಮೂಲಕ ಗಣನಾತ್ಮಕ ಕಾರ್ಯಗಳನ್ನು ನಿರ್ವಹಿಸುವುದು**
- **ಸಂಕೀರ್ಣ ಕಾರ್ಯಪ್ರವಾಹಗಳಿಗೆ ಅನೇಕ ಕಾರ್ಯಗಳನ್ನು ಸರಪಳಿಯಾಗಿ ಜೋಡಿಸುವುದು**

ಈ ಸಾಮರ್ಥ್ಯವು SLMಗಳನ್ನು ಸ್ಥಿರ ಪಠ್ಯ ಉತ್ಪಾದಕರಿಂದ ನೈಜ-ಜಗತ್ತಿನ ಕಾರ್ಯಗಳನ್ನು ನಿರ್ವಹಿಸುವ ಚುರುಕಾದ AI ಏಜೆಂಟ್‌ಗಳಾಗಿ ಪರಿವರ್ತಿಸುತ್ತದೆ.

## ಫಂಕ್ಷನ್ ಕಾಲಿಂಗ್ ಹೇಗೆ ಕಾರ್ಯನಿರ್ವಹಿಸುತ್ತದೆ

ಫಂಕ್ಷನ್ ಕಾಲಿಂಗ್ ಪ್ರಕ್ರಿಯೆ ಕ್ರಮಬದ್ಧ ಕಾರ್ಯಪ್ರವಾಹವನ್ನು ಅನುಸರಿಸುತ್ತದೆ:

### 1. ಸಾಧನ ಏಕೀಕರಣ
- **ಹೊರಗಿನ ಸಾಧನಗಳು**: SLMಗಳು ಹವಾಮಾನ APIಗಳು, ಡೇಟಾಬೇಸ್‌ಗಳು, ವೆಬ್ ಸೇವೆಗಳು ಮತ್ತು ಇತರ ಹೊರಗಿನ ವ್ಯವಸ್ಥೆಗಳಿಗೆ ಸಂಪರ್ಕಿಸಬಹುದು
- **ಫಂಕ್ಷನ್ ವ್ಯಾಖ್ಯಾನಗಳು**: ಪ್ರತಿ ಸಾಧನವು ನಿರ್ದಿಷ್ಟ ಪರಿಮಾಣಗಳು, ಇನ್‌ಪುಟ್/ಔಟ್‌ಪುಟ್ ಸ್ವರೂಪಗಳು ಮತ್ತು ವಿವರಣೆಗಳೊಂದಿಗೆ ವ್ಯಾಖ್ಯಾನಿಸಲಾಗಿದೆ
- **API ಹೊಂದಾಣಿಕೆ**: ಸಾಧನಗಳನ್ನು ಮಾನಕೀಕೃತ ಇಂಟರ್ಫೇಸ್‌ಗಳ ಮೂಲಕ ಏಕೀಕರಿಸಲಾಗುತ್ತದೆ (REST APIಗಳು, SDKಗಳು ಇತ್ಯಾದಿ)

### 2. ಫಂಕ್ಷನ್ ವ್ಯಾಖ್ಯಾನ
ಫಂಕ್ಷನ್‌ಗಳು ಮೂರು ಪ್ರಮುಖ ಘಟಕಗಳೊಂದಿಗೆ ವ್ಯಾಖ್ಯಾನಿಸಲಾಗುತ್ತವೆ:
```json
{
  "name": "function_name",
  "description": "Clear description of what the function does",
  "parameters": {
    "parameter_name": {
      "description": "What this parameter represents",
      "type": "data_type",
      "default": "default_value"
    }
  }
}
```

### 3. ಉದ್ದೇಶ ಪತ್ತೆ
- **ಸ್ವಾಭಾವಿಕ ಭಾಷಾ ಪ್ರಕ್ರಿಯೆ**: SLM ಬಳಕೆದಾರರ ಇನ್‌ಪುಟ್ ಅನ್ನು ವಿಶ್ಲೇಷಿಸಿ ಉದ್ದೇಶವನ್ನು ಅರ್ಥಮಾಡಿಕೊಳ್ಳುತ್ತದೆ
- **ಫಂಕ್ಷನ್ ಹೊಂದಾಣಿಕೆ**: ವಿನಂತಿಯನ್ನು ಪೂರೈಸಲು ಯಾವ ಫಂಕ್ಷನ್(ಗಳು) ಬೇಕು ಎಂದು ನಿರ್ಧರಿಸುತ್ತದೆ
- **ಪರಿಮಾಣ ಹೊರತೆಗೆಯುವುದು**: ಬಳಕೆದಾರರ ಸಂದೇಶದಿಂದ ಅಗತ್ಯವಿರುವ ಪರಿಮಾಣಗಳನ್ನು ಗುರುತಿಸಿ ಹೊರತೆಗೆಯುತ್ತದೆ

### 4. JSON ಔಟ್‌ಪುಟ್ ರಚನೆ
SLM ರಚಿಸುವ ಸಂರಚಿತ JSON ಒಳಗೊಂಡಿದೆ:
- ಕರೆಮಾಡಬೇಕಾದ ಫಂಕ್ಷನ್ ಹೆಸರು
- ಸೂಕ್ತ ಮೌಲ್ಯಗಳೊಂದಿಗೆ ಅಗತ್ಯ ಪರಿಮಾಣಗಳು
- ಕಾರ್ಯನಿರ್ವಹಣಾ ಸನ್ನಿವೇಶ ಮತ್ತು ಮೆಟಾಡೇಟಾ

### 5. ಹೊರಗಿನ ಕಾರ್ಯನಿರ್ವಹಣೆ
- **ಪರಿಮಾಣ ಪರಿಶೀಲನೆ**: ಎಲ್ಲಾ ಅಗತ್ಯ ಪರಿಮಾಣಗಳು ಇದ್ದಾರೆ ಮತ್ತು ಸರಿಯಾಗಿ ಸ್ವರೂಪಗೊಳಿಸಲಾಗಿದೆ ಎಂದು ಖಚಿತಪಡಿಸಿಕೊಳ್ಳುತ್ತದೆ
- **ಫಂಕ್ಷನ್ ಕಾರ್ಯನಿರ್ವಹಣೆ**: ಅಪ್ಲಿಕೇಶನ್ ನೀಡಲಾದ ಪರಿಮಾಣಗಳೊಂದಿಗೆ ನಿರ್ದಿಷ್ಟ ಫಂಕ್ಷನ್ ಅನ್ನು ಕಾರ್ಯಗತಗೊಳಿಸುತ್ತದೆ
- **ದೋಷ ನಿರ್ವಹಣೆ**: ವಿಫಲತೆಗಳು, ಸಮಯ ಮೀರಿಕೆಗಳು ಮತ್ತು ಅಮಾನ್ಯ ಪ್ರತಿಕ್ರಿಯೆಗಳನ್ನು ನಿರ್ವಹಿಸುತ್ತದೆ

### 6. ಪ್ರತಿಕ್ರಿಯೆ ಏಕೀಕರಣ
- **ಫಲಿತಾಂಶ ಪ್ರಕ್ರಿಯೆ**: ಫಂಕ್ಷನ್ ಔಟ್‌ಪುಟ್ SLMಗೆ ಹಿಂತಿರುಗಿಸಲಾಗುತ್ತದೆ
- **ಸಂದರ್ಭ ಏಕೀಕರಣ**: SLM ಫಲಿತಾಂಶಗಳನ್ನು ತನ್ನ ಪ್ರತಿಕ್ರಿಯೆಯಲ್ಲಿ ಸೇರಿಸುತ್ತದೆ
- **ಬಳಕೆದಾರ ಸಂವಹನ**: ಮಾಹಿತಿ ನೈಸರ್ಗಿಕ, ಸಂಭಾಷಣಾತ್ಮಕ ಸ್ವರೂಪದಲ್ಲಿ ಪ್ರಸ್ತುತಪಡಿಸುತ್ತದೆ

## ಅನ್ವಯಿಕೆ ದೃಶ್ಯಗಳು

### ಡೇಟಾ ಪಡೆಯುವುದು
ಸ್ವಾಭಾವಿಕ ಭಾಷಾ ಪ್ರಶ್ನೆಗಳನ್ನು ಸಂರಚಿತ API ಕರೆಗಳಿಗೆ ಪರಿವರ್ತಿಸಿ:
- **"ನನ್ನ ಇತ್ತೀಚಿನ ಆರ್ಡರ್‌ಗಳನ್ನು ತೋರಿಸಿ"** → ಬಳಕೆದಾರ ID ಮತ್ತು ದಿನಾಂಕ ಫಿಲ್ಟರ್‌ಗಳೊಂದಿಗೆ ಡೇಟಾಬೇಸ್ ಪ್ರಶ್ನೆ
- **"ಟೋಕಿಯೋದಲ್ಲಿ ಹವಾಮಾನ ಏನು?"** → ಸ್ಥಳ ಪರಿಮಾಣದೊಂದಿಗೆ ಹವಾಮಾನ API ಕರೆ
- **"ಜಾನ್‌ನಿಂದ ಇಮೇಲ್‌ಗಳನ್ನು ಕಳೆದ ವಾರ ಹುಡುಕಿ"** → ಕಳುಹಿಸುವವರ ಮತ್ತು ದಿನಾಂಕ ಫಿಲ್ಟರ್‌ಗಳೊಂದಿಗೆ ಇಮೇಲ್ ಸೇವೆ ಪ್ರಶ್ನೆ

### ಕಾರ್ಯನಿರ್ವಹಣೆ
ಬಳಕೆದಾರರ ವಿನಂತಿಗಳನ್ನು ನಿರ್ದಿಷ್ಟ ಫಂಕ್ಷನ್ ಕರೆಗಳಿಗೆ ಪರಿವರ್ತಿಸಿ:
- **"ನಾಳೆ ಮಧ್ಯಾಹ್ನ 2 ಗಂಟೆಗೆ ಸಭೆ ನಿಗದಿಪಡಿಸಿ"** → ಕ್ಯಾಲೆಂಡರ್ API ಏಕೀಕರಣ
- **"ಟೀಮ್‌ಗೆ ಸಂದೇಶ ಕಳುಹಿಸಿ"** → ಸಂವಹನ ವೇದಿಕೆ API
- **"ನನ್ನ ಫೈಲ್‌ಗಳ ಬ್ಯಾಕಪ್ ರಚಿಸಿ"** → ಫೈಲ್ ಸಿಸ್ಟಮ್ ಕಾರ್ಯಾಚರಣೆ

### ಗಣನಾತ್ಮಕ ಕಾರ್ಯಗಳು
ಸಂಕೀರ್ಣ ಗಣಿತ ಅಥವಾ ತಾರ್ಕಿಕ ಕಾರ್ಯಗಳನ್ನು ನಿರ್ವಹಿಸಿ:
- **"$10,000 ಮೇಲೆ 5% ಬಡ್ಡಿದರದಲ್ಲಿ 10 ವರ್ಷಗಳ ಸಂಯುಕ್ತ ಬಡ್ಡಿ ಲೆಕ್ಕಿಸಿ"** → ಹಣಕಾಸು ಲೆಕ್ಕಾಚಾರ ಫಂಕ್ಷನ್
- **"ಈ ಡೇಟಾಸೆಟ್‌ನಲ್ಲಿನ ಪ್ರವೃತ್ತಿಗಳನ್ನು ವಿಶ್ಲೇಷಿಸಿ"** → ಸಾಂಖ್ಯಿಕ ವಿಶ್ಲೇಷಣಾ ಸಾಧನಗಳು
- **"ವಿತರಣೆಗೆ ಈ ಮಾರ್ಗವನ್ನು ಆಪ್ಟಿಮೈಸ್ ಮಾಡಿ"** → ಮಾರ್ಗ ಆಪ್ಟಿಮೈಜೆಷನ್ ಅಲ್ಗಾರಿಥಮ್‌ಗಳು

### ಡೇಟಾ ಪ್ರಕ್ರಿಯೆ ಕಾರ್ಯಪ್ರವಾಹಗಳು
ಸಂಕೀರ್ಣ ಕಾರ್ಯಗಳಿಗೆ ಅನೇಕ ಫಂಕ್ಷನ್ ಕರೆಗಳನ್ನು ಸರಪಳಿಯಾಗಿ ಜೋಡಿಸಿ:
1. ಅನೇಕ ಮೂಲಗಳಿಂದ **ಡೇಟಾ ಪಡೆಯಿರಿ**
2. ಮಾಹಿತಿಯನ್ನು **ಪಾರ್ಸ್ ಮಾಡಿ ಮತ್ತು ಪರಿಶೀಲಿಸಿ**
3. ಡೇಟಾವನ್ನು ಅಗತ್ಯ ಸ್ವರೂಪಕ್ಕೆ **ಪರಿವರ್ತಿಸಿ**
4. ಫಲಿತಾಂಶಗಳನ್ನು ಸೂಕ್ತ ವ್ಯವಸ್ಥೆಗಳಲ್ಲಿ **ಸಂಗ್ರಹಿಸಿ**
5. **ವರದಿಗಳು** ಅಥವಾ ದೃಶ್ಯೀಕರಣಗಳನ್ನು ರಚಿಸಿ

### UI/UX ಏಕೀಕರಣ
ಚುರುಕಾದ ಇಂಟರ್ಫೇಸ್ ನವೀಕರಣಗಳನ್ನು ಸಕ್ರಿಯಗೊಳಿಸಿ:
- **"ಡ್ಯಾಶ್‌ಬೋರ್ಡ್‌ನಲ್ಲಿ ಮಾರಾಟ ಡೇಟಾವನ್ನು ತೋರಿಸಿ"** → ಚಾರ್ಟ್ ರಚನೆ ಮತ್ತು ಪ್ರದರ್ಶನ
- **"ಹೊಸ ಸ್ಥಳಗಳೊಂದಿಗೆ ನಕ್ಷೆಯನ್ನು ನವೀಕರಿಸಿ"** → ಭೂಸ್ಥಳೀಯ ಡೇಟಾ ಏಕೀಕರಣ
- **"ಇನ್ವೆಂಟರಿ ಪ್ರದರ್ಶನವನ್ನು ರಿಫ್ರೆಶ್ ಮಾಡಿ"** → ನೈಜ-ಸಮಯ ಡೇಟಾ ಸಮನ್ವಯ

## Phi-4-mini ಮತ್ತು Ollama ಜೊತೆಗೆ ಫಂಕ್ಷನ್ ಕಾಲಿಂಗ್ ಸೆಟ್‌ಅಪ್ ಮಾಡುವುದು

Microsoftನ Phi-4-mini Ollama ಮೂಲಕ ಏಕ ಮತ್ತು ಸಮಾಂತರ ಫಂಕ್ಷನ್ ಕಾಲಿಂಗ್ ಎರಡನ್ನೂ ಬೆಂಬಲಿಸುತ್ತದೆ. ಇದನ್ನು ಹೇಗೆ ಸೆಟ್‌ಅಪ್ ಮಾಡುವುದು ಇಲ್ಲಿದೆ:

### ಪೂರ್ವಾಪೇಕ್ಷಿತಗಳು
- Ollama ಆವೃತ್ತಿ 0.5.13 ಅಥವಾ ಹೆಚ್ಚಿನದು
- Phi-4-mini ಮಾದರಿ (ಶಿಫಾರಸು: `phi4-mini:3.8b-fp16`)

### ಸ್ಥಾಪನೆ ಹಂತಗಳು

#### 1. Phi-4-mini ಅನ್ನು ಇನ್‌ಸ್ಟಾಲ್ ಮಾಡಿ ಮತ್ತು ಚಾಲನೆ ಮಾಡಿ
```bash
# ಮಾದರಿಯನ್ನು ಡೌನ್‌ಲೋಡ್ ಮಾಡಿ (ಇದೀಗ ಲಭ್ಯವಿಲ್ಲದಿದ್ದರೆ)
ollama run phi4-mini:3.8b-fp16

# ಮಾದರಿ ಲಭ್ಯವಿದೆಯೇ ಎಂದು ಪರಿಶೀಲಿಸಿ
ollama list
```

#### 2. ಕಸ್ಟಮ್ ModelFile ಟೆಂಪ್ಲೇಟು ರಚಿಸಿ
Ollamaನ ಡೀಫಾಲ್ಟ್ ಟೆಂಪ್ಲೇಟುಗಳ ಸದ್ಯದ ಮಿತಿಗಳ ಕಾರಣ, ಕೆಳಗಿನ ಟೆಂಪ್ಲೇಟು ಬಳಸಿ ಕಸ್ಟಮ್ ModelFile ರಚಿಸಬೇಕು:

```modelfile
TEMPLATE """
{{- if .Messages }}
{{- if or .System .Tools }}<|system|>
{{ if .System }}{{ .System }}
{{- end }}
In addition to plain text responses, you can chose to call one or more of the provided functions.
Use the following rule to decide when to call a function:
* if the response can be generated from your internal knowledge (e.g., as in the case of queries like "What is the capital of Poland?"), do so
* if you need external information that can be obtained by calling one or more of the provided functions, generate a function calls
If you decide to call functions:
* prefix function calls with functools marker (no closing marker required)
* all function calls should be generated in a single JSON list formatted as functools[{"name": [function name], "arguments": [function arguments as JSON]}, ...]
* follow the provided JSON schema. Do not hallucinate arguments or values. Do to blindly copy values from the provided samples
* respect the argument type formatting. E.g., if the type if number and format is float, write value 7 as 7.0
* make sure you pick the right functions that match the user intent
Available functions as JSON spec:
{{- if .Tools }}
{{ .Tools }}
{{- end }}<|end|>
{{- end }}
{{- range .Messages }}
{{- if ne .Role "system" }}<|{{ .Role }}|>
{{- if and .Content (eq .Role "tools") }}
{"result": {{ .Content }}}
{{- else if .Content }}
{{ .Content }}
{{- else if .ToolCalls }}
functools[
{{- range .ToolCalls }}{{ "{" }}"name": "{{ .Function.Name }}", "arguments": {{ .Function.Arguments }}{{ "}" }}
{{- end }}]
{{- end }}<|end|>
{{- end }}
{{- end }}<|assistant|>
{{ else }}
{{- if .System }}<|system|>
{{ .System }}<|end|>{{ end }}{{ if .Prompt }}<|user|>
{{ .Prompt }}<|end|>{{ end }}<|assistant|>
{{ end }}{{ .Response }}{{ if .Response }}<|user|>{{ end }}
"""
```

#### 3. ಕಸ್ಟಮ್ ಮಾದರಿಯನ್ನು ರಚಿಸಿ
```bash
# ಮೇಲಿನ ಟೆಂಪ್ಲೇಟನ್ನು 'Modelfile' ಎಂದು ಉಳಿಸಿ ಮತ್ತು ಚಾಲನೆ ಮಾಡಿ:
ollama create phi4-mini-fc:3.8b-fp16 -f ./Modelfile
```

### ಏಕ ಫಂಕ್ಷನ್ ಕಾಲಿಂಗ್ ಉದಾಹರಣೆ

```python
import json
import requests

# ಸಾಧನ/ಕಾರ್ಯವನ್ನು ವ್ಯಾಖ್ಯಾನಿಸಿ
tools = [
    {
        "name": "get_weather",
        "description": "Get current weather information for a location",
        "parameters": {
            "location": {
                "description": "The city or location name",
                "type": "str",
                "default": "New York"
            },
            "units": {
                "description": "Temperature units (celsius or fahrenheit)",
                "type": "str",
                "default": "celsius"
            }
        }
    }
]

# ಸಾಧನಗಳನ್ನು ಒಳಗೊಂಡಿರುವ ವ್ಯವಸ್ಥೆ ಪ್ರಾಂಪ್ಟ್‌ನೊಂದಿಗೆ ಸಂದೇಶವನ್ನು ರಚಿಸಿ
messages = [
    {
        "role": "system",
        "content": "You are a helpful weather assistant",
        "tools": json.dumps(tools)
    },
    {
        "role": "user",
        "content": "What's the weather like in London today?"
    }
]

# ಒಲ್ಲಾಮಾ API ಗೆ ವಿನಂತಿ ಮಾಡಿ
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

### ಸಮಾಂತರ ಫಂಕ್ಷನ್ ಕಾಲಿಂಗ್ ಉದಾಹರಣೆ

```python
import json
import requests

# ಸಮಾಂತರ ಕಾರ್ಯಾಚರಣೆಗೆ ಹಲವಾರು ಸಾಧನಗಳನ್ನು ವ್ಯಾಖ್ಯಾನಿಸಿ
AGENT_TOOLS = {
    "booking_flight": {
        "name": "booking_flight",
        "description": "Book a flight ticket",
        "parameters": {
            "departure": {
                "description": "Departure airport code",
                "type": "str"
            },
            "destination": {
                "description": "Destination airport code", 
                "type": "str"
            },
            "outbound_date": {
                "description": "Departure date (YYYY-MM-DD)",
                "type": "str"
            },
            "return_date": {
                "description": "Return date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    },
    "booking_hotel": {
        "name": "booking_hotel",
        "description": "Book a hotel room",
        "parameters": {
            "city": {
                "description": "City name for hotel booking",
                "type": "str"
            },
            "check_in_date": {
                "description": "Check-in date (YYYY-MM-DD)",
                "type": "str"
            },
            "check_out_date": {
                "description": "Check-out date (YYYY-MM-DD)",
                "type": "str"
            }
        }
    }
}

SYSTEM_PROMPT = """
You are my travel agent with some tools available.
"""

messages = [
    {
        "role": "system",
        "content": SYSTEM_PROMPT,
        "tools": json.dumps(AGENT_TOOLS)
    },
    {
        "role": "user", 
        "content": "I need to travel from London to New York from March 21 2025 to March 27 2025. Please book both flight and hotel."
    }
]

# ಮಾದರಿ ಸಮಾಂತರ ಕಾರ್ಯವಿಧಾನ ಕರೆಗಳನ್ನು ರಚಿಸುತ್ತದೆ
response = requests.post(
    "http://localhost:11434/api/chat",
    json={
        "model": "phi4-mini-fc:3.8b-fp16",
        "messages": messages,
        "stream": False
    }
)

print(response.json())
```

## Qwen3 ಫಂಕ್ಷನ್ ಕಾಲಿಂಗ್ ಜೊತೆಗೆ ಕೆಲಸ ಮಾಡುವುದು

Qwen3 ಅತ್ಯುತ್ತಮ ಕಾರ್ಯಕ್ಷಮತೆ ಮತ್ತು ಲವಚಿಕತೆಯೊಂದಿಗೆ ಸುಧಾರಿತ ಫಂಕ್ಷನ್ ಕಾಲಿಂಗ್ ಸಾಮರ್ಥ್ಯಗಳನ್ನು ಒದಗಿಸುತ್ತದೆ. ಇದನ್ನು ಹೇಗೆ ಅನುಷ್ಠಾನಗೊಳಿಸುವುದು ಇಲ್ಲಿದೆ:

### Qwen-Agent ಫ್ರೇಮ್ವರ್ಕ್ ಬಳಕೆ

Qwen-Agent ಫಂಕ್ಷನ್ ಕಾಲಿಂಗ್ ಅನುಷ್ಠಾನವನ್ನು ಸರಳಗೊಳಿಸುವ ಉನ್ನತ ಮಟ್ಟದ ಫ್ರೇಮ್ವರ್ಕ್ ಅನ್ನು ಒದಗಿಸುತ್ತದೆ:

#### ಸ್ಥಾಪನೆ
```bash
pip install -U "qwen-agent[gui,rag,code_interpreter,mcp]"
```

#### ಮೂಲ ಸೆಟ್‌ಅಪ್

```python
import os
from qwen_agent.agents import Assistant

# LLM ಅನ್ನು ಸಂರಚಿಸಿ
llm_cfg = {
    'model': 'Qwen3-8B',
    # ಆಯ್ಕೆ 1: ಅಲಿಬಾಬಾ ಮಾದರಿ ಸ್ಟುಡಿಯೋ ಬಳಸಿ
    'model_type': 'qwen_dashscope',
    'api_key': os.getenv('DASHSCOPE_API_KEY'),
    
    # ಆಯ್ಕೆ 2: ಸ್ಥಳೀಯ ನಿಯೋಜನೆ ಬಳಸಿ
    # 'model_server': 'http://localhost:8000/v1',
    # 'api_key': 'ಖಾಲಿ',
    
    # ಚಿಂತನೆ ಮೋಡ್‌ಗೆ ಐಚ್ಛಿಕ ಸಂರಚನೆ
    'generate_cfg': {
        'thought_in_content': True,  # ಪ್ರತಿಕ್ರಿಯೆಯಲ್ಲಿ ತರ್ಕವನ್ನು ಸೇರಿಸಿ
    }
}

# MCP (ಮಾದರಿ ಸನ್ನಿವೇಶ ಪ್ರೋಟೋಕಾಲ್) ಬಳಸಿ ಸಾಧನಗಳನ್ನು ವ್ಯಾಖ್ಯಾನಿಸಿ
tools = [
    {
        'mcpServers': {
            'time': {
                'command': 'uvx',
                'args': ['mcp-server-time', '--local-timezone=Asia/Shanghai']
            },
            'fetch': {
                'command': 'uvx', 
                'args': ['mcp-server-fetch']
            }
        }
    },
    'code_interpreter',  # ಒಳಗೊಂಡಿರುವ ಕೋಡ್ ಕಾರ್ಯಗತಗೊಳಿಸುವ ಸಾಧನ
]

# ಸಹಾಯಕನನ್ನು ರಚಿಸಿ
bot = Assistant(llm=llm_cfg, function_list=tools)

# ಉದಾಹರಣೆಯ ಬಳಕೆ
messages = [
    {
        'role': 'user', 
        'content': 'What time is it now? Also, fetch the latest news from https://example.com/news'
    }
]

# ಕಾರ್ಯ ಕರೆಸುವ ಮೂಲಕ ಪ್ರತಿಕ್ರಿಯೆ ರಚಿಸಿ
for response in bot.run(messages=messages):
    print(response)
```

### ಕಸ್ಟಮ್ ಫಂಕ್ಷನ್ ಅನುಷ್ಠಾನ

ನೀವು Qwen3ಗಾಗಿ ಕಸ್ಟಮ್ ಫಂಕ್ಷನ್‌ಗಳನ್ನು ವ್ಯಾಖ್ಯಾನಿಸಬಹುದು:

```python
import json
from qwen_agent.tools.base import BaseTool

class WeatherTool(BaseTool):
    description = 'Get weather information for a specific location'
    parameters = [
        {
            'name': 'location',
            'type': 'string', 
            'description': 'City or location name',
            'required': True
        },
        {
            'name': 'units',
            'type': 'string',
            'description': 'Temperature units (celsius or fahrenheit)',
            'required': False,
            'default': 'celsius'
        }
    ]
    
    def call(self, params: str, **kwargs) -> str:
        """Execute the weather lookup"""
        params_dict = json.loads(params)
        location = params_dict.get('location')
        units = params_dict.get('units', 'celsius')
        
        # ಹವಾಮಾನ API ಕರೆ ಅನುಕರಿಸಿ
        weather_data = {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Partly cloudy',
            'humidity': '65%'
        }
        
        return json.dumps(weather_data)

# ಕಸ್ಟಮ್ ಟೂಲ್ ಬಳಸಿ
tools = [WeatherTool()]
bot = Assistant(llm=llm_cfg, function_list=tools)

messages = [{'role': 'user', 'content': 'What\'s the weather in Tokyo?'}]
response = bot.run(messages=messages)
print(list(response)[-1])
```

### ಸುಧಾರಿತ Qwen3 ವೈಶಿಷ್ಟ್ಯಗಳು

#### ಚಿಂತನೆ ಮೋಡ್ ನಿಯಂತ್ರಣ
Qwen3 ಚಿಂತನೆ ಮತ್ತು ಅಚಿಂತನೆ ಮೋಡ್‌ಗಳ ನಡುವೆ ಚುರುಕಾಗಿ ಬದಲಾಯಿಸಬಹುದು:

```python
# Enable thinking mode for complex reasoning
messages = [
    {
        'role': 'user',
        'content': '/think Solve this complex math problem: If a train travels 120 km in 1.5 hours, and another train travels 200 km in 2.5 hours, which train is faster and by how much?'
    }
]

# Disable thinking mode for simple queries
messages = [
    {
        'role': 'user', 
        'content': '/no_think What is the capital of France?'
    }
]
```

#### ಬಹು ಹಂತ ಫಂಕ್ಷನ್ ಕಾಲಿಂಗ್
Qwen3 ಅನೇಕ ಫಂಕ್ಷನ್ ಕರೆಗಳನ್ನು ಸರಪಳಿಯಾಗಿ ಜೋಡಿಸುವಲ್ಲಿ ಪರಿಣತಿ ಹೊಂದಿದೆ:

```python
# ಸಂಕೀರ್ಣ ಕಾರ್ಯಪ್ರವಾಹ ಉದಾಹರಣೆ
messages = [
    {
        'role': 'user',
        'content': '''
        I need to prepare for a business meeting:
        1. Check my calendar for conflicts tomorrow
        2. Get weather forecast for the meeting location (San Francisco)
        3. Find recent news about the client company (TechCorp)
        4. Calculate travel time from my office to their headquarters
        '''
    }
]

# Qwen3 ಸ್ವಯಂಚಾಲಿತವಾಗಿ ಅಗತ್ಯವಿರುವ ಕಾರ್ಯಕಾಲಗಳ ಕ್ರಮವನ್ನು ನಿರ್ಧರಿಸುತ್ತದೆ
```

## Foundry Local ಏಕೀಕರಣ

Microsoftನ Foundry Local ಮಾದರಿಗಳನ್ನು ಸ್ಥಳೀಯವಾಗಿ ಓಡಿಸಲು OpenAI-ಹೊಂದಾಣಿಕೆಯ API ಅನ್ನು ಒದಗಿಸುತ್ತದೆ, ಹೆಚ್ಚಿದ ಗೌಪ್ಯತೆ ಮತ್ತು ಕಾರ್ಯಕ್ಷಮತೆಯೊಂದಿಗೆ.

### ಸೆಟ್‌ಅಪ್ ಮತ್ತು ಸ್ಥಾಪನೆ

#### ವಿಂಡೋಸ್
[Foundry Local ಬಿಡುಗಡೆಗಳ ಪುಟ](https://github.com/microsoft/Foundry-Local/releases) ನಿಂದ ಇನ್‌ಸ್ಟಾಲರ್ ಡೌನ್‌ಲೋಡ್ ಮಾಡಿ ಮತ್ತು ಸ್ಥಾಪನೆ ಸೂಚನೆಗಳನ್ನು ಅನುಸರಿಸಿ.

#### macOS
```bash
brew tap microsoft/foundrylocal
brew install foundrylocal
```

#### ಮೂಲ ಬಳಕೆ

```python
import openai
from foundry_local import FoundryLocalManager

# ಮಾದರಿ ಉಪನಾಮದಿಂದ ಪ್ರಾರಂಭಿಸಿ
alias = "phi-3.5-mini"  # ಅಥವಾ ಯಾವುದೇ ಬೆಂಬಲಿತ ಮಾದರಿ
manager = FoundryLocalManager(alias)

# ಸ್ಥಳೀಯ ಎಂಡ್ಪಾಯಿಂಟ್‌ಗೆ ಸೂಚಿಸುವ OpenAI ಕ್ಲೈಂಟ್ ರಚಿಸಿ
client = openai.OpenAI(
    base_url=manager.endpoint,
    api_key=manager.api_key
)

# ಮಾದರಿಗಾಗಿ ಕಾರ್ಯಗಳನ್ನು ವ್ಯಾಖ್ಯಾನಿಸಿ
functions = [
    {
        "name": "calculate_tax",
        "description": "Calculate tax amount based on income and rate",
        "parameters": {
            "type": "object",
            "properties": {
                "income": {
                    "type": "number",
                    "description": "Annual income amount"
                },
                "tax_rate": {
                    "type": "number", 
                    "description": "Tax rate as decimal (e.g., 0.25 for 25%)"
                }
            },
            "required": ["income", "tax_rate"]
        }
    }
]

# ಕಾರ್ಯ ಕರೆ ವಿನಂತಿ ಮಾಡಿ
response = client.chat.completions.create(
    model=manager.model_info.id,
    messages=[
        {
            "role": "user",
            "content": "Calculate the tax for someone earning $75,000 with a 22% tax rate"
        }
    ],
    functions=functions,
    function_call="auto"
)

print(response.choices[0].message.content)
```

### ಸುಧಾರಿತ Foundry Local ವೈಶಿಷ್ಟ್ಯಗಳು

#### ಮಾದರಿ ನಿರ್ವಹಣೆ
```bash
# ಲಭ್ಯವಿರುವ ಮಾದರಿಗಳನ್ನು ಪಟ್ಟಿ ಮಾಡಿ
foundry model list

# ನಿರ್ದಿಷ್ಟ ಮಾದರಿಯನ್ನು ಡೌನ್‌ಲೋಡ್ ಮಾಡಿ
foundry model download phi-3.5-mini

# ಮಾದರಿಯನ್ನು ಸಂವಹನಾತ್ಮಕವಾಗಿ ಚಾಲನೆ ಮಾಡಿ
foundry model run phi-3.5-mini

# ಕ್ಯಾಶೆನಿಂದ ಮಾದರಿಯನ್ನು ತೆಗೆದುಹಾಕಿ
foundry model remove phi-3.5-mini

# ಎಲ್ಲಾ ಕ್ಯಾಶೆ ಮಾಡಲಾದ ಮಾದರಿಗಳನ್ನು ಅಳಿಸಿ
foundry model remove "*"
```

#### ಕಾರ್ಯಕ್ಷಮತೆ ಆಪ್ಟಿಮೈಜೆಷನ್
Foundry Local ನಿಮ್ಮ ಹಾರ್ಡ್‌ವೇರ್‌ಗೆ ಅತ್ಯುತ್ತಮ ಮಾದರಿ ರೂಪಾಂತರವನ್ನು ಸ್ವಯಂಚಾಲಿತವಾಗಿ ಆಯ್ಕೆಮಾಡುತ್ತದೆ:
- **CUDA GPU**: GPU-ಆಪ್ಟಿಮೈಸ್ ಮಾಡಿದ ಮಾದರಿಗಳನ್ನು ಡೌನ್‌ಲೋಡ್ ಮಾಡುತ್ತದೆ
- **Qualcomm NPU**: NPU-ವೇಗವರ್ಧಿತ ರೂಪಾಂತರಗಳನ್ನು ಬಳಸುತ್ತದೆ
- **CPU-ಮಾತ್ರ**: CPU-ಆಪ್ಟಿಮೈಸ್ ಮಾಡಿದ ಮಾದರಿಗಳನ್ನು ಆಯ್ಕೆಮಾಡುತ್ತದೆ

## ಉತ್ತಮ ಅಭ್ಯಾಸಗಳು ಮತ್ತು ಸಮಸ್ಯೆ ಪರಿಹಾರ

### ಫಂಕ್ಷನ್ ವ್ಯಾಖ್ಯಾನ ಉತ್ತಮ ಅಭ್ಯಾಸಗಳು

#### 1. ಸ್ಪಷ್ಟ ಮತ್ತು ವಿವರಣಾತ್ಮಕ ಹೆಸರುಕರಣ
```python
# ಉತ್ತಮ
{
    "name": "get_stock_price",
    "description": "Retrieve current stock price for a given symbol"
}

# ತಪ್ಪಿಸಿಕೊಳ್ಳಿ
{
    "name": "get_data", 
    "description": "Gets data"
}
```

#### 2. ಸಮಗ್ರ ಪರಿಮಾಣ ವ್ಯಾಖ್ಯಾನಗಳು
```python
{
    "name": "send_email",
    "description": "Send an email message to specified recipients",
    "parameters": {
        "to": {
            "type": "array",
            "items": {"type": "string"},
            "description": "List of recipient email addresses",
            "required": True
        },
        "subject": {
            "type": "string",
            "description": "Email subject line",
            "required": True
        },
        "body": {
            "type": "string", 
            "description": "Email message content",
            "required": True
        },
        "priority": {
            "type": "string",
            "enum": ["low", "normal", "high"],
            "description": "Email priority level",
            "default": "normal",
            "required": False
        }
    }
}
```

#### 3. ಇನ್‌ಪುಟ್ ಪರಿಶೀಲನೆ ಮತ್ತು ದೋಷ ನಿರ್ವಹಣೆ
```python
def execute_function(function_name, parameters):
    try:
        # ಅಗತ್ಯವಾದ ಪರಿಮಾಣಗಳನ್ನು ಪರಿಶೀಲಿಸಿ
        if function_name == "send_email":
            if not parameters.get("to") or not parameters.get("subject"):
                return {"error": "Missing required parameters: to, subject"}
            
            # ಇಮೇಲ್ ಸ್ವರೂಪವನ್ನು ಪರಿಶೀಲಿಸಿ
            email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
            for email in parameters["to"]:
                if not re.match(email_pattern, email):
                    return {"error": f"Invalid email format: {email}"}
        
        # ಕಾರ್ಯಾಚರಣೆ ತರ್ಕವನ್ನು ನಿರ್ವಹಿಸಿ
        result = perform_actual_function(function_name, parameters)
        return {"success": True, "data": result}
        
    except Exception as e:
        return {"error": str(e)}
```

### ಸಾಮಾನ್ಯ ಸಮಸ್ಯೆಗಳು ಮತ್ತು ಪರಿಹಾರಗಳು

#### ಸಮಸ್ಯೆ 1: ಫಂಕ್ಷನ್ ಕರೆ ಆಗುತ್ತಿಲ್ಲ
**ಲಕ್ಷಣಗಳು**: ಮಾದರಿ ಪಠ್ಯದಿಂದ ಪ್ರತಿಕ್ರಿಯಿಸುತ್ತದೆ, ಫಂಕ್ಷನ್ ಕರೆ ಮಾಡುತ್ತಿಲ್ಲ

**ಪರಿಹಾರಗಳು**:
1. **ಫಂಕ್ಷನ್ ವಿವರಣೆ ಪರಿಶೀಲಿಸಿ**: ಅದು ಬಳಕೆದಾರರ ಉದ್ದೇಶಕ್ಕೆ ಸ್ಪಷ್ಟವಾಗಿ ಹೊಂದಿಕೆಯಾಗಿದೆಯೇ ಎಂದು ಖಚಿತಪಡಿಸಿಕೊಳ್ಳಿ
2. **ಪರಿಮಾಣ ವ್ಯಾಖ್ಯಾನಗಳನ್ನು ಪರಿಶೀಲಿಸಿ**: ಎಲ್ಲಾ ಅಗತ್ಯ ಪರಿಮಾಣಗಳು ಸರಿಯಾಗಿ ವ್ಯಾಖ್ಯಾನಗೊಂಡಿವೆ ಎಂದು ಖಚಿತಪಡಿಸಿಕೊಳ್ಳಿ
3. **ಸಿಸ್ಟಮ್ ಪ್ರಾಂಪ್ಟ್ ಪರಿಶೀಲಿಸಿ**: ಯಾವಾಗ ಫಂಕ್ಷನ್‌ಗಳನ್ನು ಬಳಸಬೇಕೆಂದು ಸ್ಪಷ್ಟ ಸೂಚನೆಗಳನ್ನು ಸೇರಿಸಿ
4. **ನಿರ್ದಿಷ್ಟ ವಿನಂತಿಗಳೊಂದಿಗೆ ಪರೀಕ್ಷಿಸಿ**: "ದಯವಿಟ್ಟು ಲಂಡನ್‌ಗಾಗಿ ಹವಾಮಾನ ಫಂಕ್ಷನ್ ಬಳಸಿ" ಎಂದು ಪ್ರಯತ್ನಿಸಿ

#### ಸಮಸ್ಯೆ 2: ತಪ್ಪು ಪರಿಮಾಣಗಳು
**ಲಕ್ಷಣಗಳು**: ಫಂಕ್ಷನ್ ತಪ್ಪು ಅಥವಾ ಕೊರತೆಯಾದ ಪರಿಮಾಣಗಳೊಂದಿಗೆ ಕರೆ ಮಾಡಲಾಗಿದೆ

**ಪರಿಹಾರಗಳು**:
1. **ಪರಿಮಾಣ ಉದಾಹರಣೆಗಳನ್ನು ಸೇರಿಸಿ**: ಪರಿಮಾಣ ವಿವರಣೆಗಳಲ್ಲಿ ಮಾದರಿ ಮೌಲ್ಯಗಳನ್ನು ಸೇರಿಸಿ
2. **enum ನಿಯಮಗಳನ್ನು ಬಳಸಿ**: ಸಾಧ್ಯವಾದರೆ ಪರಿಮಾಣ ಮೌಲ್ಯಗಳನ್ನು ನಿರ್ದಿಷ್ಟ ಆಯ್ಕೆಗಳಿಗೆ ಮಿತಿಗೊಳಿಸಿ
3. **ಫಾಲ್ಬ್ಯಾಕ್ ಮೌಲ್ಯಗಳನ್ನು ಅನುಷ್ಠಾನಗೊಳಿಸಿ**: ಐಚ್ಛಿಕ ಪರಿಮಾಣಗಳಿಗೆ ಸೂಕ್ತ ಡೀಫಾಲ್ಟ್ ಮೌಲ್ಯಗಳನ್ನು ಒದಗಿಸಿ

```python
{
    "name": "book_restaurant",
    "parameters": {
        "cuisine": {
            "type": "string",
            "enum": ["italian", "chinese", "mexican", "american", "french"],
            "description": "Type of cuisine (example: 'italian' for Italian food)"
        },
        "party_size": {
            "type": "integer",
            "minimum": 1,
            "maximum": 20,
            "description": "Number of people (example: 4 for a family of four)"
        }
    }
}
```

#### ಸಮಸ್ಯೆ 3: ಸಮಾಂತರ ಫಂಕ್ಷನ್ ಕಾಲಿಂಗ್ ವಿಫಲತೆಗಳು
**ಲಕ್ಷಣಗಳು**: ಅನೇಕ ಫಂಕ್ಷನ್‌ಗಳು ಕಾರ್ಯಗತಗೊಳ್ಳಬೇಕಾಗಿದ್ದಾಗ ಒಂದೇ ಒಂದು ಕಾರ್ಯಗತಗೊಳ್ಳುತ್ತದೆ

**ಪರಿಹಾರಗಳು**:
1. **ಮಾದರಿ ಬೆಂಬಲ ಪರಿಶೀಲಿಸಿ**: ನಿಮ್ಮ ಮಾದರಿ ಸಮಾಂತರ ಫಂಕ್ಷನ್ ಕಾಲಿಂಗ್ ಬೆಂಬಲಿಸುತ್ತಿದೆಯೇ ಎಂದು ಖಚಿತಪಡಿಸಿಕೊಳ್ಳಿ
2. **ಸಿಸ್ಟಮ್ ಪ್ರಾಂಪ್ಟ್ ನವೀಕರಿಸಿ**: "ಕೆಲವು ಸಾಧನಗಳು" ಅಥವಾ "ಬಹು ಸಾಧನಗಳು" ಎಂಬ ಪದಗಳನ್ನು ಸಿಸ್ಟಮ್ ಸಂದೇಶದಲ್ಲಿ ಸೇರಿಸಿ
3. **ತಕ್ಕಮಟ್ಟಿನ ಮಾದರಿ ಆವೃತ್ತಿಗಳನ್ನು ಬಳಸಿ**: Ollamaಗೆ Phi-4-mini:3.8b-fp16 ಶಿಫಾರಸು ಮಾಡಲಾಗಿದೆ

#### ಸಮಸ್ಯೆ 4: Ollama ಟೆಂಪ್ಲೇಟು ಸಮಸ್ಯೆಗಳು
**ಲಕ್ಷಣಗಳು**: ಡೀಫಾಲ್ಟ್ Ollama ಸೆಟ್‌ಅಪ್‌ನಲ್ಲಿ ಫಂಕ್ಷನ್ ಕಾಲಿಂಗ್ ಕಾರ್ಯನಿರ್ವಹಿಸುವುದಿಲ್ಲ

**ಪರಿಹಾರಗಳು**:
1. **ಕಸ್ಟಮ್ ModelFile ಬಳಸಿ**: ಈ ಟ್ಯುಟೋರಿಯಲ್‌ನಲ್ಲಿ ನೀಡಲಾದ ಸರಿಪಡಿಸಿದ ಟೆಂಪ್ಲೇಟನ್ನು ಅನ್ವಯಿಸಿ
2. **Ollama ನವೀಕರಿಸಿ**: ಆವೃತ್ತಿ 0.5.13 ಅಥವಾ ಹೆಚ್ಚಿನದನ್ನು ಬಳಸಿ
3. **ಮಾದರಿ ಕ್ವಾಂಟೈಜೆಷನ್ ಪರಿಶೀಲಿಸಿ**: ಹೆಚ್ಚು ಕ್ವಾಂಟೈಜ್ ಮಟ್ಟಗಳು (Q8_0, fp16) ಹೆಚ್ಚು ಕ್ವಾಂಟೈಜ್ ಮಾಡಲಾದ ಆವೃತ್ತಿಗಳಿಗಿಂತ ಉತ್ತಮವಾಗಿ ಕಾರ್ಯನಿರ್ವಹಿಸುತ್ತವೆ

### ಕಾರ್ಯಕ್ಷಮತೆ ಆಪ್ಟಿಮೈಜೆಷನ್

#### 1. ಪರಿಣಾಮಕಾರಿ ಫಂಕ್ಷನ್ ವಿನ್ಯಾಸ
- **ಫಂಕ್ಷನ್‌ಗಳನ್ನು ಕೇಂದ್ರೀಕರಿಸಿ**: ಪ್ರತಿ ಫಂಕ್ಷನ್ ಒಂದೇ ಸ್ಪಷ್ಟ ಉದ್ದೇಶ ಹೊಂದಿರಲಿ
- **ಹೊರಗಿನ ಅವಲಂಬನೆಗಳನ್ನು ಕಡಿಮೆ ಮಾಡಿ**: ಸಾಧ್ಯವಾದಷ್ಟು API ಕರೆಗಳು ಮತ್ತು ನೆಟ್‌ವರ್ಕ್ ವಿನಂತಿಗಳನ್ನು ಕಡಿಮೆ ಮಾಡಿ
- **ಫಲಿತಾಂಶಗಳನ್ನು ಕ್ಯಾಶ್ ಮಾಡಿ**: ಹೆಚ್ಚಾಗಿ ಕೇಳಲಾಗುವ ಡೇಟಾವನ್ನು ಸಂಗ್ರಹಿಸಿ ಪ್ರತಿಕ್ರಿಯೆ ಸಮಯವನ್ನು ಸುಧಾರಿಸಿ

#### 2. ಬ್ಯಾಚಿಂಗ್ ಮತ್ತು ಅಸಿಂಕ್ರೋನಸ್ ಕಾರ್ಯಾಚರಣೆಗಳು
```python
import asyncio
import aiohttp

async def batch_function_calls(function_calls):
    """Execute multiple function calls concurrently"""
    async with aiohttp.ClientSession() as session:
        tasks = []
        for call in function_calls:
            if call["name"] == "fetch_url":
                task = fetch_url_async(session, call["parameters"]["url"])
                tasks.append(task)
        
        results = await asyncio.gather(*tasks)
        return results

async def fetch_url_async(session, url):
    async with session.get(url) as response:
        return await response.text()
```

#### 3. ಸಂಪನ್ಮೂಲ ನಿರ್ವಹಣೆ
- **ಕನೆಕ್ಷನ್ ಪೂಲಿಂಗ್**: ಡೇಟಾಬೇಸ್ ಮತ್ತು API ಸಂಪರ್ಕಗಳನ್ನು ಮರುಬಳಕೆ ಮಾಡಿ
- **ರೇಟ್ ಲಿಮಿಟಿಂಗ್**: ಹೊರಗಿನ APIಗಳಿಗೆ ಸೂಕ್ತ ರೇಟ್ ನಿಯಂತ್ರಣವನ್ನು ಅನುಷ್ಠಾನಗೊಳಿಸಿ
- **ಟೈಮೌಟ್ ನಿರ್ವಹಣೆ**: ಎಲ್ಲಾ ಹೊರಗಿನ ಕರೆಗಳಿಗೆ ಯುಕ್ತ ಸಮಯ ಮೀರಿಕೆಗಳನ್ನು ಹೊಂದಿಸಿ

## ಅಧಿಕೃತ ಉದಾಹರಣೆಗಳು

### ಬಹು ಏಜೆಂಟ್ ಸಹಕಾರ ವ್ಯವಸ್ಥೆ

```python
import json
from typing import List, Dict
from qwen_agent.agents import Assistant

class MultiAgentSystem:
    def __init__(self):
        # ಸಂಶೋಧನಾ ಏಜೆಂಟ್
        self.research_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[
                {'mcpServers': {'search': {'command': 'uvx', 'args': ['mcp-server-search']}}},
                {'mcpServers': {'fetch': {'command': 'uvx', 'args': ['mcp-server-fetch']}}}
            ]
        )
        
        # ವಿಶ್ಲೇಷಣಾ ಏಜೆಂಟ್
        self.analysis_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=['code_interpreter']
        )
        
        # ಸಂವಹನ ಏಜೆಂಟ್
        self.comm_agent = Assistant(
            llm={'model': 'Qwen3-8B', 'model_server': 'http://localhost:8000/v1'},
            function_list=[self.create_email_tool(), self.create_slack_tool()]
        )
    
    def create_email_tool(self):
        """Custom email sending tool"""
        class EmailTool:
            name = "send_email"
            description = "Send email to specified recipients"
            parameters = {
                "to": {"type": "string", "description": "Recipient email"},
                "subject": {"type": "string", "description": "Email subject"},
                "body": {"type": "string", "description": "Email content"}
            }
            
            def call(self, params):
                # ನಿಜವಾದ ಇಮೇಲ್ ಕಳುಹಿಸುವ ಲಾಜಿಕ್ ಅನ್ನು ಜಾರಿಗೊಳಿಸಿ
                return f"Email sent successfully to {params['to']}"
        
        return EmailTool()
    
    def create_slack_tool(self):
        """Custom Slack messaging tool"""  
        class SlackTool:
            name = "send_slack"
            description = "Send message to Slack channel"
            parameters = {
                "channel": {"type": "string", "description": "Slack channel"},
                "message": {"type": "string", "description": "Message content"}
            }
            
            def call(self, params):
                # ನಿಜವಾದ Slack API ಕರೆ ಜಾರಿಗೊಳಿಸಿ
                return f"Message sent to {params['channel']}"
        
        return SlackTool()
    
    async def process_complex_request(self, user_request: str):
        """Process complex multi-step requests using multiple agents"""
        
        # ಹಂತ 1: ಸಂಶೋಧನಾ ಹಂತ
        research_prompt = f"Research the following topic and gather relevant information: {user_request}"
        research_results = []
        for response in self.research_agent.run([{'role': 'user', 'content': research_prompt}]):
            research_results.append(response)
        
        # ಹಂತ 2: ವಿಶ್ಲೇಷಣಾ ಹಂತ
        analysis_prompt = f"Analyze the following research data and provide insights: {research_results[-1]}"
        analysis_results = []
        for response in self.analysis_agent.run([{'role': 'user', 'content': analysis_prompt}]):
            analysis_results.append(response)
        
        # ಹಂತ 3: ಸಂವಹನ ಹಂತ
        comm_prompt = f"Create a summary report and send it via email: {analysis_results[-1]}"
        comm_results = []
        for response in self.comm_agent.run([{'role': 'user', 'content': comm_prompt}]):
            comm_results.append(response)
        
        return {
            'research': research_results[-1],
            'analysis': analysis_results[-1], 
            'communication': comm_results[-1]
        }

# ಬಳಕೆ ಉದಾಹರಣೆ
async def main():
    system = MultiAgentSystem()
    
    request = """
    Analyze the impact of remote work on productivity in tech companies. 
    Research recent studies, analyze the data, and send a summary to our team.
    """
    
    results = await system.process_complex_request(request)
    print("Multi-agent processing complete:", results)

# ಉದಾಹರಣೆಯನ್ನು ಚಾಲನೆ ಮಾಡಿ
# asyncio.run(main())
```

### ಚುರುಕಾದ ಸಾಧನ ಆಯ್ಕೆ ವ್ಯವಸ್ಥೆ

```python
class DynamicToolSelector:
    def __init__(self):
        self.available_tools = {
            'weather': {
                'description': 'Get weather information',
                'domains': ['weather', 'temperature', 'forecast', 'climate'],
                'function': self.get_weather
            },
            'calculator': {
                'description': 'Perform mathematical calculations',
                'domains': ['math', 'calculate', 'compute', 'arithmetic'],
                'function': self.calculate
            },
            'web_search': {
                'description': 'Search the internet for information',
                'domains': ['search', 'find', 'lookup', 'research'],
                'function': self.web_search
            },
            'file_manager': {
                'description': 'Manage files and directories',
                'domains': ['file', 'directory', 'save', 'load', 'delete'],
                'function': self.manage_files
            }
        }
    
    def analyze_intent(self, user_input: str) -> List[str]:
        """Analyze user input to determine which tools might be needed"""
        user_words = user_input.lower().split()
        relevant_tools = []
        
        for tool_name, tool_info in self.available_tools.items():
            for domain in tool_info['domains']:
                if domain in user_words:
                    relevant_tools.append(tool_name)
                    break
        
        return relevant_tools
    
    def get_tool_definitions(self, tool_names: List[str]) -> List[Dict]:
        """Generate function definitions for selected tools"""
        definitions = []
        
        for tool_name in tool_names:
            if tool_name == 'weather':
                definitions.append({
                    'name': 'get_weather',
                    'description': 'Get current weather information',
                    'parameters': {
                        'location': {'type': 'string', 'description': 'City or location name'},
                        'units': {'type': 'string', 'enum': ['celsius', 'fahrenheit'], 'default': 'celsius'}
                    }
                })
            elif tool_name == 'calculator':
                definitions.append({
                    'name': 'calculate',
                    'description': 'Perform mathematical calculations',
                    'parameters': {
                        'expression': {'type': 'string', 'description': 'Mathematical expression to evaluate'},
                        'precision': {'type': 'integer', 'default': 2, 'description': 'Decimal places for result'}
                    }
                })
            # ಅಗತ್ಯವಿದ್ದರೆ ಇನ್ನಷ್ಟು ಉಪಕರಣ ವ್ಯಾಖ್ಯಾನಗಳನ್ನು ಸೇರಿಸಿ
        
        return definitions
    
    def get_weather(self, location: str, units: str = 'celsius') -> Dict:
        """Mock weather function"""
        return {
            'location': location,
            'temperature': '22°C' if units == 'celsius' else '72°F',
            'condition': 'Sunny',
            'humidity': '60%'
        }
    
    def calculate(self, expression: str, precision: int = 2) -> Dict:
        """Safe mathematical calculation"""
        try:
            # ಡೆಮೊಗಾಗಿ ಸರಳ ಮೌಲ್ಯಮಾಪನ - ಉತ್ಪಾದನೆಯಲ್ಲಿ, ಸರಿಯಾದ ಗಣಿತ ಪಾರ್ಸರ್ ಬಳಸಿ
            import math
            allowed_names = {
                k: v for k, v in math.__dict__.items() if not k.startswith("__")
            }
            allowed_names.update({"abs": abs, "round": round})
            
            result = eval(expression, {"__builtins__": {}}, allowed_names)
            return {
                'expression': expression,
                'result': round(float(result), precision),
                'success': True
            }
        except Exception as e:
            return {
                'expression': expression,
                'error': str(e),
                'success': False
            }
    
    def web_search(self, query: str, max_results: int = 5) -> Dict:
        """Mock web search function"""
        return {
            'query': query,
            'results': [
                {'title': f'Result {i+1} for {query}', 'url': f'https://example{i+1}.com'}
                for i in range(max_results)
            ]
        }
    
    def manage_files(self, action: str, file_path: str, content: str = None) -> Dict:
        """Mock file management function"""
        return {
            'action': action,
            'file_path': file_path,
            'success': True,
            'message': f'Successfully {action}ed file: {file_path}'
        }

# ಬಳಕೆ ಉದಾಹರಣೆ
def smart_assistant_with_dynamic_tools():
    selector = DynamicToolSelector()
    
    user_requests = [
        "What's the weather like in New York and calculate 15% tip on $50?",
        "Search for recent AI developments and save the results to a file",
        "Calculate the area of a circle with radius 10 and check weather in Tokyo"
    ]
    
    for request in user_requests:
        print(f"\nUser Request: {request}")
        
        # ಯಾವ ಉಪಕರಣಗಳು ಬೇಕಾಗಬಹುದು ಎಂದು ವಿಶ್ಲೇಷಿಸಿ
        relevant_tools = selector.analyze_intent(request)
        print(f"Relevant Tools: {relevant_tools}")
        
        # LLM ಗಾಗಿ ಕಾರ್ಯ ವ್ಯಾಖ್ಯಾನಗಳನ್ನು ಪಡೆಯಿರಿ
        tool_definitions = selector.get_tool_definitions(relevant_tools)
        print(f"Tool Definitions: {len(tool_definitions)} functions available")
        
        # ನಿಜವಾದ ಅನುಷ್ಠಾನದಲ್ಲಿ, ನೀವು ಇದನ್ನು ನಿಮ್ಮ LLM ಗೆ ಪಾಸ್ ಮಾಡುತ್ತೀರಿ
        # ನಂತರ LLM ಯಾವ ಕಾರ್ಯಗಳನ್ನು ಕರೆಸಬೇಕು ಮತ್ತು ಯಾವ ಪ್ಯಾರಾಮೀಟರ್ ಗಳೊಂದಿಗೆ ಎಂದು ನಿರ್ಧರಿಸುತ್ತದೆ

### ಎಂಟರ್‌ಪ್ರೈಸ್ ಏಕೀಕರಣ ಉದಾಹರಣೆ

```python
import asyncio
import json
from typing import Dict, List, Any
from dataclasses import dataclass
from datetime import datetime

@dataclass
class FunctionResult:
    """Standard result format for all function calls"""
    success: bool
    data: Any = None
    error: str = None
    execution_time: float = 0.0
    timestamp: datetime = None

class EnterpriseAIAgent:
    """Production-ready AI agent with comprehensive function calling capabilities"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.functions = {}
        self.audit_log = []
        self.rate_limiters = {}
        
        # ಕೋರ್ ವ್ಯವಹಾರ ಕಾರ್ಯಗಳನ್ನು ಪ್ರಾರಂಭಿಸಿ
        self._register_core_functions()
    
    def _register_core_functions(self):
        """Register all available business functions"""
        
        # CRM ಕಾರ್ಯಗಳು
        self.register_function(
            name="get_customer_info",
            description="Retrieve customer information from CRM",
            parameters={
                "customer_id": {"type": "string", "required": True},
                "include_history": {"type": "boolean", "default": False}
            },
            handler=self._get_customer_info,
            rate_limit=100  # ಪ್ರತಿ ನಿಮಿಷಕ್ಕೆ ಕರೆಗಳು
        )
        
        # ಮಾರಾಟ ಕಾರ್ಯಗಳು
        self.register_function(
            name="create_sales_opportunity",
            description="Create a new sales opportunity",
            parameters={
                "customer_id": {"type": "string", "required": True},
                "product_id": {"type": "string", "required": True},
                "estimated_value": {"type": "number", "required": True},
                "expected_close_date": {"type": "string", "required": True}
            },
            handler=self._create_sales_opportunity,
            rate_limit=50
        )
        
        # ವಿಶ್ಲೇಷಣೆ ಕಾರ್ಯಗಳು
        self.register_function(
            name="generate_sales_report",
            description="Generate sales performance report",
            parameters={
                "period": {"type": "string", "enum": ["daily", "weekly", "monthly", "quarterly"]},
                "region": {"type": "string", "required": False},
                "product_category": {"type": "string", "required": False}
            },
            handler=self._generate_sales_report,
            rate_limit=10
        )
        
        # ಸೂಚನೆ ಕಾರ್ಯಗಳು
        self.register_function(
            name="send_notification",
            description="Send notification to team members",
            parameters={
                "recipients": {"type": "array", "items": {"type": "string"}},
                "message": {"type": "string", "required": True},
                "priority": {"type": "string", "enum": ["low", "medium", "high"], "default": "medium"},
                "channel": {"type": "string", "enum": ["email", "slack", "teams"], "default": "email"}
            },
            handler=self._send_notification,
            rate_limit=200
        )
    
    def register_function(self, name: str, description: str, parameters: Dict, 
                         handler: callable, rate_limit: int = 60):
        """Register a new function with the agent"""
        self.functions[name] = {
            'description': description,
            'parameters': parameters,
            'handler': handler,
            'rate_limit': rate_limit,
            'call_count': 0,
            'last_reset': datetime.now()
        }
    
    async def execute_function(self, function_name: str, parameters: Dict) -> FunctionResult:
        """Execute a function with comprehensive error handling and logging"""
        start_time = datetime.now()
        
        try:
            # ಕಾರ್ಯವಿದೆ ಎಂದು ಪರಿಶೀಲಿಸಿ
            if function_name not in self.functions:
                return FunctionResult(
                    success=False,
                    error=f"Function '{function_name}' not found",
                    timestamp=start_time
                )
            
            # ದರ ಮಿತಿಗಳನ್ನು ಪರಿಶೀಲಿಸಿ
            if not self._check_rate_limit(function_name):
                return FunctionResult(
                    success=False,
                    error=f"Rate limit exceeded for function '{function_name}'",
                    timestamp=start_time
                )
            
            # ಪ್ಯಾರಾಮೀಟರ್ ಗಳನ್ನು ಪರಿಶೀಲಿಸಿ
            validation_result = self._validate_parameters(function_name, parameters)
            if not validation_result.success:
                return validation_result
            
            # ಕಾರ್ಯವನ್ನು ನಿರ್ವಹಿಸಿ
            func_info = self.functions[function_name]
            handler = func_info['handler']
            
            if asyncio.iscoroutinefunction(handler):
                result_data = await handler(**parameters)
            else:
                result_data = handler(**parameters)
            
            execution_time = (datetime.now() - start_time).total_seconds()
            
            result = FunctionResult(
                success=True,
                data=result_data,
                execution_time=execution_time,
                timestamp=start_time
            )
            
            # ಯಶಸ್ವಿ ನಿರ್ವಹಣೆಯನ್ನು ಲಾಗ್ ಮಾಡಿ
            self._log_function_call(function_name, parameters, result)
            
            return result
            
        except Exception as e:
            execution_time = (datetime.now() - start_time).total_seconds()
            result = FunctionResult(
                success=False,
                error=str(e),
                execution_time=execution_time,
                timestamp=start_time
            )
            
            # ವಿಫಲ ನಿರ್ವಹಣೆಯನ್ನು ಲಾಗ್ ಮಾಡಿ
            self._log_function_call(function_name, parameters, result)
            
            return result
    
    def _check_rate_limit(self, function_name: str) -> bool:
        """Check if function call is within rate limits"""
        func_info = self.functions[function_name]
        now = datetime.now()
        
        # ಒಂದು ನಿಮಿಷ ಕಳೆದರೆ ಕೌಂಟರ್ ಅನ್ನು ಮರುಹೊಂದಿಸಿ
        if (now - func_info['last_reset']).seconds >= 60:
            func_info['call_count'] = 0
            func_info['last_reset'] = now
        
        # ಮಿತಿಯೊಳಗಿದೆಯೇ ಎಂದು ಪರಿಶೀಲಿಸಿ
        if func_info['call_count'] >= func_info['rate_limit']:
            return False
        
        func_info['call_count'] += 1
        return True
    
    def _validate_parameters(self, function_name: str, parameters: Dict) -> FunctionResult:
        """Validate function parameters"""
        func_params = self.functions[function_name]['parameters']
        
        # ಅಗತ್ಯವಿರುವ ಪ್ಯಾರಾಮೀಟರ್ ಗಳನ್ನು ಪರಿಶೀಲಿಸಿ
        for param_name, param_info in func_params.items():
            if param_info.get('required', False) and param_name not in parameters:
                return FunctionResult(
                    success=False,
                    error=f"Missing required parameter: {param_name}"
                )
        
        # ಪ್ಯಾರಾಮೀಟರ್ ಪ್ರಕಾರಗಳು ಮತ್ತು ನಿಯಮಗಳನ್ನು ಪರಿಶೀಲಿಸಿ
        for param_name, value in parameters.items():
            if param_name in func_params:
                param_info = func_params[param_name]
                
                # ಪ್ರಕಾರ ಪರಿಶೀಲನೆ
                expected_type = param_info.get('type')
                if expected_type == 'string' and not isinstance(value, str):
                    return FunctionResult(
                        success=False,
                        error=f"Parameter '{param_name}' must be a string"
                    )
                elif expected_type == 'number' and not isinstance(value, (int, float)):
                    return FunctionResult(
                        success=False,
                        error=f"Parameter '{param_name}' must be a number"
                    )
                elif expected_type == 'boolean' and not isinstance(value, bool):
                    return FunctionResult(
                        success=False,
                        error=f"Parameter '{param_name}' must be a boolean"
                    )
                
                # ಎನಮ್ ಪರಿಶೀಲನೆ
                if 'enum' in param_info and value not in param_info['enum']:
                    return FunctionResult(
                        success=False,
                        error=f"Parameter '{param_name}' must be one of: {param_info['enum']}"
                    )
        
        return FunctionResult(success=True)
    
    def _log_function_call(self, function_name: str, parameters: Dict, result: FunctionResult):
        """Log function call for audit purposes"""
        log_entry = {
            'timestamp': result.timestamp.isoformat(),
            'function_name': function_name,
            'parameters': parameters,
            'success': result.success,
            'execution_time': result.execution_time,
            'error': result.error if not result.success else None
        }
        
        self.audit_log.append(log_entry)
        
        # ಐಚ್ಛಿಕವಾಗಿ ಹೊರಗಿನ ಲಾಗಿಂಗ್ ವ್ಯವಸ್ಥೆಗೆ ಬರೆಯಿರಿ
        if self.config.get('enable_external_logging', False):
            self._write_to_external_log(log_entry)
    
    def _write_to_external_log(self, log_entry: Dict):
        """Write log entry to external logging system"""
        # ಅನುಷ್ಠಾನವು ನಿಮ್ಮ ಲಾಗಿಂಗ್ ಮೂಲಸೌಕರ್ಯ ಮೇಲೆ ಅವಲಂಬಿತವಾಗಿರುತ್ತದೆ
        # ಉದಾ., ELK ಸ್ಟ್ಯಾಕ್, ಕ್ಲೌಡ್ ವಾಚ್, ಇತ್ಯಾದಿಗೆ ಕಳುಹಿಸಿ
        pass
    
    # ವ್ಯವಹಾರ ಕಾರ್ಯ ಅನುಷ್ಠಾನಗಳು
    async def _get_customer_info(self, customer_id: str, include_history: bool = False) -> Dict:
        """Retrieve customer information from CRM system"""
        # ಡೇಟಾಬೇಸ್/API ಕರೆ ಅನುಕರಿಸಿ
        await asyncio.sleep(0.1)  # ನೆಟ್‌ವರ್ಕ್ ವಿಳಂಬವನ್ನು ಅನುಕರಿಸಿ
        
        customer_data = {
            'customer_id': customer_id,
            'name': 'John Doe',
            'email': 'john.doe@example.com',
            'phone': '+1-555-0123',
            'status': 'active',
            'tier': 'premium'
        }
        
        if include_history:
            customer_data['purchase_history'] = [
                {'date': '2024-01-15', 'product': 'Product A', 'amount': 1500},
                {'date': '2024-03-22', 'product': 'Product B', 'amount': 2300}
            ]
        
        return customer_data
    
    async def _create_sales_opportunity(self, customer_id: str, product_id: str, 
                                      estimated_value: float, expected_close_date: str) -> Dict:
        """Create a new sales opportunity"""
        # CRM API ಕರೆ ಅನುಕರಿಸಿ
        await asyncio.sleep(0.2)
        
        opportunity_id = f"OPP-{datetime.now().strftime('%Y%m%d%H%M%S')}"
        
        return {
            'opportunity_id': opportunity_id,
            'customer_id': customer_id,
            'product_id': product_id,
            'estimated_value': estimated_value,
            'expected_close_date': expected_close_date,
            'status': 'open',
            'created_date': datetime.now().isoformat()
        }
    
    async def _generate_sales_report(self, period: str, region: str = None, 
                                   product_category: str = None) -> Dict:
        """Generate comprehensive sales report"""
        # ಡೇಟಾ ಸಂಗ್ರಹಣೆಯನ್ನು ಅನುಕರಿಸಿ
        await asyncio.sleep(0.5)
        
        return {
            'report_id': f"RPT-{datetime.now().strftime('%Y%m%d%H%M%S')}",
            'period': period,
            'region': region,
            'product_category': product_category,
            'total_sales': 125000.00,
            'total_opportunities': 45,
            'conversion_rate': 0.67,
            'top_products': [
                {'product_id': 'PROD-001', 'sales': 45000},
                {'product_id': 'PROD-002', 'sales': 32000}
            ],
            'generated_at': datetime.now().isoformat()
        }
    
    async def _send_notification(self, recipients: List[str], message: str, 
                               priority: str = 'medium', channel: str = 'email') -> Dict:
        """Send notification through specified channel"""
        # ಸೂಚನೆ ಸೇವೆ ಕರೆ ಅನುಕರಿಸಿ
        await asyncio.sleep(0.1)
        
        notification_id = f"NOTIF-{datetime.now().strftime('%Y%m%d%H%M%S')}"
        
        return {
            'notification_id': notification_id,
            'recipients': recipients,
            'channel': channel,
            'priority': priority,
            'status': 'sent',
            'sent_at': datetime.now().isoformat()
        }
    
    def get_function_definitions(self) -> List[Dict]:
        """Get OpenAI-compatible function definitions for all registered functions"""
        definitions = []
        
        for func_name, func_info in self.functions.items():
            definition = {
                'name': func_name,
                'description': func_info['description'],
                'parameters': {
                    'type': 'object',
                    'properties': {},
                    'required': []
                }
            }
            
            for param_name, param_info in func_info['parameters'].items():
                definition['parameters']['properties'][param_name] = {
                    'type': param_info['type'],
                    'description': param_info.get('description', '')
                }
                
                if 'enum' in param_info:
                    definition['parameters']['properties'][param_name]['enum'] = param_info['enum']
                
                if 'default' in param_info:
                    definition['parameters']['properties'][param_name]['default'] = param_info['default']
                
                if param_info.get('required', False):
                    definition['parameters']['required'].append(param_name)
            
            definitions.append(definition)
        
        return definitions

# ಎಂಟರ್‌ಪ್ರೈಸ್ ಏಕೀಕರಣಕ್ಕಾಗಿ ಬಳಕೆ ಉದಾಹರಣೆ
async def enterprise_demo():
    """Demonstrate enterprise AI agent capabilities"""
    
    config = {
        'enable_external_logging': True,
        'max_concurrent_functions': 10,
        'default_timeout': 30
    }
    
    agent = EnterpriseAIAgent(config)
    
    # ಉದಾಹರಣೆ 1: ಗ್ರಾಹಕ ವಿಚಾರಣೆ ಪ್ರಕ್ರಿಯೆ
    print("=== Customer Inquiry Processing ===")
    
    # ಗ್ರಾಹಕ ಮಾಹಿತಿಯನ್ನು ಪಡೆಯಿರಿ
    result = await agent.execute_function(
        'get_customer_info',
        {'customer_id': 'CUST-12345', 'include_history': True}
    )
    
    if result.success:
        print(f"Customer Info Retrieved: {result.data['name']}")
        print(f"Execution Time: {result.execution_time:.3f}s")
    
    # ಉದಾಹರಣೆ 2: ಮಾರಾಟ ಅವಕಾಶ ಸೃಷ್ಟಿ
    print("\n=== Sales Opportunity Creation ===")
    
    result = await agent.execute_function(
        'create_sales_opportunity',
        {
            'customer_id': 'CUST-12345',
            'product_id': 'PROD-001',
            'estimated_value': 15000.0,
            'expected_close_date': '2025-09-30'
        }
    )
    
    if result.success:
        print(f"Opportunity Created: {result.data['opportunity_id']}")
    
    # ಉದಾಹರಣೆ 3: ಬ್ಯಾಚ್ ಕಾರ್ಯಾಚರಣೆಗಳು
    print("\n=== Batch Operations ===")
    
    tasks = [
        agent.execute_function('generate_sales_report', {'period': 'monthly'}),
        agent.execute_function('send_notification', {
            'recipients': ['manager@company.com'],
            'message': 'New opportunity created',
            'priority': 'high',
            'channel': 'email'
        })
    ]
    
    results = await asyncio.gather(*tasks)
    
    for i, result in enumerate(results):
        if result.success:
            print(f"Task {i+1} completed successfully")
        else:
            print(f"Task {i+1} failed: {result.error}")
    
    # ಆಡಿಟ್ ಲಾಗ್ ಪ್ರದರ್ಶಿಸಿ
    print(f"\n=== Audit Log ({len(agent.audit_log)} entries) ===")
    for entry in agent.audit_log[-3:]:  # ಕೊನೆಯ 3 ಎಂಟ್ರಿಗಳನ್ನು ತೋರಿಸಿ
        print(f"{entry['timestamp']}: {entry['function_name']} - {'SUCCESS' if entry['success'] else 'FAILED'}")

# ಎಂಟರ್‌ಪ್ರೈಸ್ ಡೆಮೊ ಅನ್ನು ಚಾಲನೆ ಮಾಡಿ
# asyncio.run(enterprise_demo())
```

## ಸಮಾರೋಪ

ಸಣ್ಣ ಭಾಷಾ ಮಾದರಿಗಳಲ್ಲಿ ಫಂಕ್ಷನ್ ಕಾಲಿಂಗ್ ಸ್ಥಿರ AI ಸಹಾಯಕರಿಂದ ನೈಜ ಜಗತ್ತಿನೊಂದಿಗೆ ಸಂವಹನ ಮಾಡುವ ಚುರುಕಾದ, ಸಾಮರ್ಥ್ಯವಂತ ಏಜೆಂಟ್‌ಗಳಾಗಿ ಪರಿವರ್ತನೆಯಾಗಿದೆ. ಈ ಟ್ಯುಟೋರಿಯಲ್‌ನಲ್ಲಿ ನಾವು ಒಳಗೊಂಡಿದ್ದೇವೆ:

### ಪ್ರಮುಖ ಅಂಶಗಳು

1. **ಮೂಲಭೂತ ಅರ್ಥಮಾಡಿಕೊಳ್ಳುವುದು**: ಫಂಕ್ಷನ್ ಕಾಲಿಂಗ್ SLMಗಳನ್ನು ಹೊರಗಿನ ಸಾಧನಗಳು ಮತ್ತು ಸೇವೆಗಳೊಂದಿಗೆ ಸಂಪರ್ಕಿಸುವ ಮೂಲಕ ತರಬೇತಿ ಡೇಟಾದ ಮೀರಿದಂತೆ ವಿಸ್ತರಿಸುತ್ತದೆ.

2. **ಅನುಷ್ಠಾನ ಲವಚಿಕತೆ**: ಕಸ್ಟಮ್ ಟೆಂಪ್ಲೇಟುಗಳೊಂದಿಗೆ ಕಡಿಮೆ ಮಟ್ಟದ ಅನುಷ್ಠಾನದಿಂದ Qwen-Agent ಮತ್ತು Foundry Localಂತಹ ಉನ್ನತ ಮಟ್ಟದ ಫ್ರೇಮ್ವರ್ಕ್‌ಗಳವರೆಗೆ ಅನೇಕ ವಿಧಾನಗಳಿವೆ.

3. **ಉತ್ಪಾದನಾ ಪರಿಗಣನೆಗಳು**: ಎಂಟರ್‌ಪ್ರೈಸ್ ನಿಯೋಜನೆಗಳಿಗೆ ದೋಷ ನಿರ್ವಹಣೆ, ರೇಟ್ ನಿಯಂತ್ರಣ, ಭದ್ರತೆ ಮತ್ತು ಆಡಿಟ್ ಲಾಗಿಂಗ್‌ಗೆ ಗಮನ ನೀಡಬೇಕು.

4. **ಕಾರ್ಯಕ್ಷಮತೆ ಆಪ್ಟಿಮೈಜೆಷನ್**: ಸರಿಯಾದ ಫಂಕ್ಷನ್ ವಿನ್ಯಾಸ, ಪರಿಣಾಮಕಾರಿ ಕಾರ್ಯನಿರ್ವಹಣೆ ಮತ್ತು ಸ್ಮಾರ್ಟ್ ಕ್ಯಾಶಿಂಗ್ ಪ್ರತಿಕ್ರಿಯೆ ಸಮಯವನ್ನು ಬಹುಮಟ್ಟಿಗೆ ಸುಧಾರಿಸುತ್ತದೆ.

### ಭವಿಷ್ಯದ ದಿಕ್ಕುಗಳು

SLM ತಂತ್ರಜ್ಞಾನ ಮುಂದುವರಿದಂತೆ ನಾವು ನಿರೀಕ್ಷಿಸಬಹುದು:

- **ಸುಧಾರಿತ ಫಂಕ್ಷನ್ ಕಾಲಿಂಗ್ ನಿಖರತೆ**: ಉತ್ತಮ ಉದ್ದೇಶ ಪತ್ತೆ ಮತ್ತು ಪರಿಮಾಣ ಹೊರತೆಗೆಯುವಿಕೆ
- **ಮೇಲ್ಮಟ್ಟದ ಸಮಾಂತರ ಪ್ರಕ್ರಿಯೆ**: ಹೆಚ್ಚು ಸುಧಾರಿತ ಬಹು-ಫಂಕ್ಷನ್ ಸಂಯೋಜನೆ
- **ಉತ್ತಮ ಏಕೀಕರಣ ಮಾನದಂಡಗಳು**: ಸಾಧನ ಏಕೀಕರಣಕ್ಕೆ ಮಾನಕೀಕೃತ ಪ್ರೋಟೋಕಾಲ್‌ಗಳು
- **ಸುಧಾರಿತ ಭದ್ರತಾ ವೈಶಿಷ್ಟ್ಯಗಳು**: ಉತ್ತಮ ಪ್ರಮಾಣೀಕರಣ ಮತ್ತು ಪ್ರಾಧಿಕಾರ ವ್ಯವಸ್ಥೆಗಳು
- **ವಿಸ್ತೃತ ಪರಿಸರ**: ಪೂರ್ವನಿರ್ಮಿತ ಫಂಕ್ಷನ್‌ಗಳು ಮತ್ತು ಏಕೀಕರಣಗಳ ಗ್ರೋಥ್

### ಪ್ರಾರಂಭಿಸುವುದು

ನಿಮ್ಮ ಯೋಜನೆಗಳಲ್ಲಿ ಫಂಕ್ಷನ್ ಕಾಲಿಂಗ್ ಅನುಷ್ಠಾನಗೊಳಿಸಲು:

1. **ಸರಳದಿಂದ ಪ್ರಾರಂಭಿಸಿ**: ಮೂಲ ಏಕ-ಫಂಕ್ಷನ್ ದೃಶ್ಯಗಳಿಂದ ಪ್ರಾರಂಭಿಸಿ
2. **ನಿಮ್ಮ ಫ್ರೇಮ್ವರ್ಕ್ ಆಯ್ಕೆಮಾಡಿ**: ನೇರ ಅನುಷ್ಠಾನ (Ollama/Phi-4) ಅಥವಾ ಫ್ರೇಮ್ವರ್ಕ್ ಸಹಾಯಿತ (Qwen-Agent) ಆಯ್ಕೆಮಾಡಿ
3. **ಫಂಕ್ಷನ್‌ಗಳನ್ನು ಜಾಗರೂಕತೆಯಿಂದ ವಿನ್ಯಾಸಗೊಳಿಸಿ**: ಸ್ಪಷ್ಟ, ಚೆನ್ನಾಗಿ ದಾಖಲೆಗೊಳಿಸಿದ ಫಂಕ್ಷನ್ ವ್ಯಾಖ್ಯಾನಗಳ ಮೇಲೆ ಕೇಂದ್ರೀಕರಿಸಿ
4. **ದೋಷ ನಿರ್ವಹಣೆ ಅನುಷ್ಠಾನಗೊಳಿಸಿ**: ಆರಂಭದಿಂದಲೇ ಬಲವಾದ ದೋಷ ನಿರ್ವಹಣೆಯನ್ನು ನಿರ್ಮಿಸಿ
5. **ಕ್ರಮೇಣ ವಿಸ್ತರಿಸಿ**: ಅನುಭವ ಪಡೆಯುತ್ತಾ ಸರಳದಿಂದ ಸಂಕೀರ್ಣ ದೃಶ್ಯಗಳಿಗೆ ಸಾಗಿರಿ

ಫಂಕ್ಷನ್ ಕಾಲಿಂಗ್ SLMಗಳನ್ನು ಅದ್ಭುತ ಪಠ್ಯ ಉತ್ಪಾದಕರಿಂದ ನೈಜ ಜಗತ್ತಿನ ಸಮಸ್ಯೆಗಳನ್ನು ಪರಿಹರಿಸುವ ಪ್ರಾಯೋಗಿಕ AI ಏಜೆಂಟ್‌ಗಳಾಗಿ ಪರಿವರ್ತಿಸುತ್ತದೆ. ಈ ಟ್ಯುಟೋರಿಯಲ್‌ನಲ್ಲಿ ವಿವರಿಸಿದ ಮಾದರಿಗಳು ಮತ್ತು ಅಭ್ಯಾಸಗಳನ್ನು ಅನುಸರಿಸುವ ಮೂಲಕ, ನೀವು ಶಕ್ತಿಶಾಲಿ, ನಂಬಿಗಸ್ತ AI ವ್ಯವಸ್ಥೆಗಳನ್ನು ನಿರ್ಮಿಸಬಹುದು, ಅವು ಪರಂಪರাগত ಚಾಟ್ ಇಂಟರ್ಫೇಸ್‌ಗಳಿಗಿಂತ ಬಹಳ ದೂರ ವಿಸ್ತಾರ ಹೊಂದಿವೆ.

### ಸಂಪನ್ಮೂಲಗಳು ಮತ್ತು ಉಲ್ಲೇಖಗಳು

- **Phi-4 ಮಾದರಿಗಳು**: [Hugging Face ಸಂಗ್ರಹ](https://huggingface.co/collections/microsoft/phi-4-677e9380e514feb5577a40e4)
- **Qwen3 ಡಾಕ್ಯುಮೆಂಟೇಶನ್**: [ಅಧಿಕೃತ Qwen ಡಾಕ್ಯುಮೆಂಟೇಶನ್](https://qwen.readthedocs.io/)
- **Ollama**: [ಅಧಿಕೃತ ವೆಬ್‌ಸೈಟ್](https://ollama.com/)
- **Foundry Local**: [GitHub ರೆಪೊ](https://github.com/microsoft/Foundry-Local)
- **ಫಂಕ್ಷನ್ ಕಾಲಿಂಗ್ ಉತ್ತಮ ಅಭ್ಯಾಸಗಳು**: [Hugging Face ಮಾರ್ಗದರ್ಶಿ](https://huggingface.co/docs/hugs/en/guides/function-calling)

ಫಂಕ್ಷನ್ ಕಾಲಿಂಗ್ ಒಂದು ಅಭಿವೃದ್ಧಿಯಾಗುತ್ತಿರುವ ಕ್ಷೇತ್ರವಾಗಿದೆ, ಮತ್ತು ನಿಮ್ಮ ಆಯ್ಕೆಮಾಡಿದ ಫ್ರೇಮ್ವರ್ಕ್‌ಗಳು ಮತ್ತು ಮಾದರಿಗಳ ಇತ್ತೀಚಿನ ಅಭಿವೃದ್ಧಿಗಳನ್ನು ಅನುಸರಿಸುವುದು ಹೆಚ್ಚು ಪರಿಣಾಮಕಾರಿ AI ಏಜೆಂಟ್‌ಗಳನ್ನು ನಿರ್ಮಿಸಲು ಸಹಾಯ ಮಾಡುತ್ತದೆ.

## ➡️ ಮುಂದೇನು

- [03: ಮಾದರಿ ಸನ್ನಿವೇಶ ಪ್ರೋಟೋಕಾಲ್ (MCP) ಏಕೀಕರಣ](./03.IntroduceMCP.md)

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
**ಅಸ್ವೀಕರಣ**:  
ಈ ದಸ್ತಾವೇಜು AI ಅನುವಾದ ಸೇವೆ [Co-op Translator](https://github.com/Azure/co-op-translator) ಬಳಸಿ ಅನುವಾದಿಸಲಾಗಿದೆ. ನಾವು ನಿಖರತೆಯಿಗಾಗಿ ಪ್ರಯತ್ನಿಸುತ್ತಿದ್ದರೂ, ಸ್ವಯಂಚಾಲಿತ ಅನುವಾದಗಳಲ್ಲಿ ದೋಷಗಳು ಅಥವಾ ತಪ್ಪುಗಳು ಇರಬಹುದು ಎಂದು ದಯವಿಟ್ಟು ಗಮನಿಸಿ. ಮೂಲ ಭಾಷೆಯಲ್ಲಿರುವ ಮೂಲ ದಸ್ತಾವೇಜನ್ನು ಅಧಿಕೃತ ಮೂಲವಾಗಿ ಪರಿಗಣಿಸಬೇಕು. ಮಹತ್ವದ ಮಾಹಿತಿಗಾಗಿ, ವೃತ್ತಿಪರ ಮಾನವ ಅನುವಾದವನ್ನು ಶಿಫಾರಸು ಮಾಡಲಾಗುತ್ತದೆ. ಈ ಅನುವಾದ ಬಳಕೆಯಿಂದ ಉಂಟಾಗುವ ಯಾವುದೇ ತಪ್ಪು ಅರ್ಥಮಾಡಿಕೊಳ್ಳುವಿಕೆ ಅಥವಾ ತಪ್ಪು ವಿವರಣೆಗಳಿಗೆ ನಾವು ಹೊಣೆಗಾರರಾಗುವುದಿಲ್ಲ.
<!-- CO-OP TRANSLATOR DISCLAIMER END -->